# **ВОПРОСЫ С СОБЕСЕДОВАНИЙ ПО ANDROID**

## **Содержание**

1. [Базовые вопросы](#базовые-вопросы)

    1.1 [Что такое SOLID?](#1-что-такое-solid)

    1.2 [Назовите основные принципы ооп.](#2-назовите-основные-принципы-ооп)

    1.3 [Что такое класс? Что такое интерфейс? Какая между ними разница?](#3-что-такое-класс-что-такое-интерфейс-какая-между-ними-разница)

    1.4 [Назовите базовые типы данных.](#4-назовите-базовые-типы-данных)

    1.5 [В чем отличие примитивных типов от объектов?](#5-в-чем-отличие-примитивных-типов-от-объектов)

    1.6 [Какая разница между абстрактным классом и интерфейсом?](#6-какая-разница-между-абстрактным-классом-и-интерфейсом)

    1.7 [Что такое паттерны проектирования? Какие паттерны вы знаете?](#7-что-такое-паттерны-проектирования-какие-паттерны-вы-знаете)

    1.8 [Чем отличается Java от Kotlin?](#8-чем-отличается-java-от-kotlin)

2. [Алгоритмы](#алгоритмы)

    2.1 [Что такое алгоритм и как выбрать правильный?](#1-что-такое-алгоритм-и-как-выбрать-правильный)

    2.2 [Что такое сложность алгоритма? Как и с помощью чего её можно вычислить?](#2-что-такое-сложность-алгоритма-как-и-с-помощью-чего-её-можно-вычислить)

    2.3 [Что такое нотация big-O?](#3-что-такое-нотация-big-o)

    2.4 [Что такое рекурсия?](#4-что-такое-рекурсия)

    2.5 [Какие алгоритмы сортировки вы знаете?](#5-какие-алгоритмы-сортировки-вы-знаете)

3. [Структуры данных](#структуры-данных)

    3.1 [Расскажите о таких структурах данных, как List, Set, Map?](#1-расскажите-о-таких-структурах-данных-как-list-set-map)

    3.2 [Какая разница между ArrayList и LinkedList?](#2-какая-разница-между-arraylist-и-linkedlist)

4. [Хранение данных](#хранение-данных)

    4.1 [Как можно хранить данные в Android?](#1-как-можно-хранить-данные-в-android)

    4.2 [Когда следует использовать SharedPreferences?](#2-когда-следует-использовать-sharedpreferences)

    4.3 [Из каких компонентов состоит библиотека Room?](#3-из-каких-компонентов-состоит-библиотека-room)

    4.4 [Что такое @PrimaryKey, @Ignore, @Embedded, @TypeConverters в Room?](#4-что-такое-primarykey-ignore-embedded-typeconverters-в-room)

    4.5 [Для чего нужна миграция в базах данных?](#5-для-чего-нужна-миграция-в-базах-данных)

5. [Работа с сетью](#работа-с-сетью)

    5.1 [Что такое JSON, XML?](#1-что-такое-json-xml)

    5.2 [Какие варианты реализации работы с сервером?](#2-какие-варианты-реализации-работы-с-сервером)

    5.3 [Что такое REST?](#3-что-такое-rest)

6. [Многопоточность](#многопоточность)

    6.1 [Что такое процесс?](#1-что-такое-процесс)

    6.2 [Что такое поток?](#2-что-такое-поток)

    6.3 [Для чего используют ключевое слово synchronized?](#3-для-чего-используют-ключевое-слово-synchronized)

    6.4 [Зачем синхронизировать потоки?](#4-зачем-синхронизировать-потоки)

    6.5 [Какая разница между синхронным и асинхронным исполнением?](#5-какая-разница-между-синхронным-и-асинхронным-исполнением)

    6.6 [Как мы можем создать поток в Java?](#6-как-мы-можем-создать-поток-в-java)

    6.7 [Как мы можем создать поток в Kotlin?](#7-как-мы-можем-создать-поток-в-kotlin)

    6.8 [Что такое deadlock?](#7-что-такое-deadlock)

    6.9 [Какие варианты реализации многопоточности есть в Android?](#8-какие-варианты-реализации-многопоточности-есть-в-android)

    6.10 [Что такое main thread? Какие операции нужно выполнять на main thread, а какие нельзя делать?](#9-что-такое-main-thread-какие-операции-нужно-выполнять-на-main-thread-а-какие-нельзя-делать)

7. [Java Core](#java-core)

    7.1 [Зачем используют ключевые слова final, finally и finalize?](#1-зачем-используют-ключевые-слова-final-finally-и-finalize)

8. [RxJava](#rxjava)

9. [Android SDK](#android-sdk)
  
    
10. [Kotlin](#kotlin)

    10.1 [Как вы понимаете термин Null-safety](#1-как-вы-понимаете-термин-null-safety)
    
    10.2 [Что такое nullable и non-nullable типы? Какая разница между val и var?](#2-что-такое-nullable-и-non-nullable-типы-какая-разница-между-val-и-var)
    
    10.3 [Как задекларировать getter/setter для property?](#3-как-задекларировать-gettersetter-для-property)
    
    10.4 [Почему классы Kotlin по умолчанию final?](#4-почему-классы-kotlin-по-умолчанию-final)

    10.5 [Что такое sealed class?](#5-что-такое-sealed-class)

    10.6 [Что такое data class?](#6-что-такое-data-class)

    10.7 [Какая разница между sealed class и enum?](#7-какая-разница-между-sealed-class-и-enum)

    10.8 [Почему у Kotlin нет checked exceptions?](#8-почему-у-kotlin-нет-checked-exceptions)

    10.9 [Что такое Extensions (расширение)? Использовали ли вы их на практике?](#9-что-такое-extensions-расширение-использовали-ли-вы-их-на-практике)

    10.10 [Что такое перегрузка операторов (operator overloading)? Зачем нужен этот механизм?](#10-что-такое-перегрузка-операторов-operator-overloading-зачем-нужен-этот-механизм)
       
    10.11 [Как работают примитивы в Kotlin?](#11-как-работают-примитивы-в-kotlin)
    
    10.12 [Расскажите об объекте Unit в Kotlin.](#12-расскажите-об-объекте-unit-в-kotlin)

    10.13 [Расскажите об объекте Any в Kotlin.](#13-расскажите-об-объекте-any-в-kotlin)
        
    10.14 [Как создать Singleton объект в Kotlin?](#14-как-создать-singleton-объект-в-kotlin)
    
    10.15 [Что такое companion object?](#15-что-такое-companion-object)
    
    10.16 [Чем отличается const val от val?](#16-чем-отличается-const-val-от-val)
    
    10.17 [Какие знаете модификаторы доступа?](#17-какие-знаете-модификаторы-доступа)

    10.18 [Что означает модификатор lateinit?](#18-что-означает-модификатор-lateinit)

    10.19 [Coroutines – что это за механизм? Использовали ли его на практике?](#19-coroutines-–-что-это-за-механизм-использовали-ли-его-на-практике)

    10.20 [Зачем нужны Coroutines? Чем они лучше обычных тредов?](#20-зачем-нужны-coroutines-чем-они-лучше-обычных-тредов)
        
    10.21 [Что такое suspend-функция?](#21-что-такое-suspend-функция)
    
    10.22 [Что такое Job?](#22-что-такое-job)
    
    10.23 [Что такое Dispatcher? Какие есть виды?](#23-что-такое-dispatcher-какие-есть-виды)
    
    10.24 [Что такое Scope?](#24-что-такое-scope)
    
11. [Другое](#другое)

12. [Практические задачи](#практические-задачи)


## **Базовые вопросы** 

#### [Содержание<---](#содержание)

### **1. Что такое [SOLID](https://javarush.com/groups/posts/3650-principih-solid-kotorihe-sdelajut-kod-chijshe)?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>S</b>ingle Responsibility Principle (Принцип единственной ответственности)</LI>
        <LI><b>O</b>pen-Closed Principle (Принцип открытости-закрытости)</LI>
        <LI><b>L</b>iskov Substitution Principle (Принцип подстановки Барбары Лисков)</LI>
        <LI><b>I</b>nterface Segregation Principle (Принцип разделения интерфейса)</LI>
        <LI><b>D</b>ependency Inversion Principle (Принцип инверсии зависимостей)</LI>
        <UL><LI>Принцип предлагает, чтобы высокоуровневые модули не зависели от низкоуровневых модулей, а оба типа зависимостей должны зависеть от абстракций. Кроме того, он говорит о том, что абстракции не должны зависеть от деталей реализации, а детали реализации должны зависеть от абстракций.</UL></LI>
    </UL>
</details>

### **2. Назовите основные принципы ООП.**

<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Наследование</b> - создание новых сущностей(шаблонов) на основе уже существующих.</LI>
        <LI><b>Полиморфизм</b> - возможность иметь разные формы для одной и той же сущности. Он     делится на статический (мнимый) и динамический (истинный). Суть разделения  заключается в том, что разные виды происходят в разные этапы выполенения программы.  Статический (мнимый) - происходит на этапе компиляции, из примеров могу назвать  приведение типов, но это не применимо к строго типизированный языкам, к которым  относиться Kotlin и Java. Динамический (истинный) - происходит во рвемя выполенния   кода. Как вариант это несколько методов с разными входными аргументами.</LI>
        <UL>
            <LI><b>3 типа полиморфизма в Kotlin:</b></LI>
            <UL>
                <LI><b>Ad hoc (по случаю)</b> – одна функция определяется для различных типов данных. В классе прописывается несколько функций, которые принимают разные параметры. При вызове этой функции, компилятор определяет какая функция сработает по количеству и типам передаваемых параметров. Минус такого подхода, в том, что нужно наделать множество реализаций этой функции.</LI>
                <LI><b>Subtyping (полиморфизм включения)</b> – это реализация через принцип подстановки Барбары Лисков. Это один из принципов объектно-ориентированного программирования из аббревиатуры SOLID. Почитайте об этом. А звучит он так: функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом. То есть объект более узкого типа всегда может использоваться там, где может использоваться объект более широкого типа. Здесь, кстати и может сбить с толку факт отношений наследования родителя и потомка, о чем я упоминал вначале.</LI>
                <LI><b>Parametric (параметрический)</b> – программа может быть реализована через обобщенные типы. То есть без ориентации на конкретный тип. Касаемо Kotlin – это история про дженерики (или обобщенное программирование). О них поговорим в другой раз.</LI>
            </UL>
        </UL>
        <LI><b>Инкапсуляци</b> - сокрытие реализации.</LI>
        <LI><b>Абстракция</b> - набор общих характеристик.</LI>
        <LI><b>Посылка сообщений</b> - форма связи, взаимодействия между сущностями.</LI>
        <LI><b>Переиспользование</b> - все что перечислено выше работает на повторное использование кода.</LI>
    </UL>
</details>

### **3. Что такое класс? Что такое интерфейс? Какая между ними разница?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Класс</b> - это способ описания сущности. Его шаблон, который имеет минимальный набор общих характеристик для работы с ним. Классы являются ссылочным типом данных, тоесть в куче(heap) будет храниться только ссылка на данные из стэка. </LI>
        <UL>
            <LI><b>Объект</b> - это экземпляр класса, который имеет все теже поля и методы, но значения в разных объектха могут различаться. </LI>
        </UL>
        <LI><b>Интерфейс</b> изначально это шаблон проектирования. В Kotlin - это некое соглашение для класса, который будет использовать (наследоваться) интерфейс, которое обязывает последнего реализовать заключенный с интерфейсом контракт(методы/поля).
<pre><code><span style="color:orange;">interface</span> Movable{
    <span style="color:orange;">var</span> <span style="color:MediumOrchid;">speed</span>: Int  <span style="color:gray;">// объявление свойства</span>
    <span style="color:orange;">fun</span> move</span>()      // определение функции без реализации</span>
    <span style="color:orange;">fun</span> stop(){     // определение функции с реализацией по умолчанию</span>
        println("Остановка"</span>)
    }
}
<span style="color:orange;">class</span> Car : Movable{
    <span style="color:gray;">// обязательно реализовать(override) только то,
    <span style="color:gray;">// что в interface не имеет реализации по умолчанию</span>
    <span style="color:orange;">override var</span> <span style="color:MediumOrchid;">speed</span> = 60</span>
    <span style="color:orange;">override fun</span> <span style="color:DodgerBlue;">move</span>(){
        println(<span style="color:green;">"Машина едет со скоростью $speed км/ч"</span>)
    }
}</pre></code>        
        </LI>
        <LI><b>Отличия</b>
        <UL>
            <LI><b>interface</b> под оберткой представляет из себя <code>abstract class</code>, который запрещает создавать объекты этого класса.</LI>
            <LI><b>class</b> в kotlin изначально <code>final</code>, наследоваться можно только от <code>open</code> классов, при этом наследование может быть только одинарное, <code>interface</code> в свою очередь поддерживает множественное наследование. </LI>
        </UL>
        </LI>
    </UL>
</details>

### **4. Назовите базовые типы данных.**

<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>В Kotlin все типы это классы. Any - топ класс, от которого наследуются другие классы, также есть подтип всех типов - Nothing(ничего).</LI>
        <LI>Все примитвные типы разделены на нулабельные и нет, дополнительно можно выделить платформ тайп, используется для обратной совместимости, когда не известено объект нулабельный или нет. </LI>
        <LI>Функциональные типы.</LI>
        <UL>
        <LI><b>Функции высшего порядка (Higher-Order Functions)</b>: Это функции, которые принимают другие функции в качестве параметров или возвращают функции в качестве результатов. Например:<br>
<pre><code><span style="color:orange;">fun</span> <span style="color:DodgerBlue;">operateOnNumbers</span>(
  a: Int, b: Int,
  operation: (Int, Int) -> Int
): Int {
  <span style="color:orange;">return</span> operation(a, b)
}</pre></code>
        </LI>
        <LI><b>Типы функций (Function Types)</b>: Это типы данных, которые представляют собой сигнатуры функций. В Kotlin функциональные типы обычно записываются в следующем формате: (parameters) -> return_type. Например:<br>
<pre><code><span style="color:orange;">val</span> <span style="color:DodgerBlue;">add</span>: (Int, Int) -> Int = { a, b -> a + b }</pre></code>
        </LI>
        </UL>
        <LI>Коллекции, которые дополнительно разделены на изменяемые и нет.</LI>
    </UL>
</details>

### **5. В чем отличие примитивных типов от объектов?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>Кроме описанного ранее поясния, что такое <a href='#2-что-такое-класс-что-такое-интерфейс-какая-между-ними-разница'>класс</a>, также можно отметить, что объект будет иметь еще методы, которые будут выполнять какие либо действия.</LI>
    </UL>
</details>

### **6. Какая разница между абстрактным классом и интерфейсом?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Абстрактный класс</b> - это заготовка для классов, которые имеют общую сущность, а интерфейса - это контракт, который обязывает другой объект реализовать некоторые свойства/методы.</LI>
        <LI>Также абстрактный класс может иметь стандратное значение для поля, тоесть хранить какие-либо данные. Интерфейс же может иметь только стандартную реализацию методов.</LI>
    </UL>
</details>

### **7. Что такое паттерны проектирования? Какие паттерны вы знаете?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Паттерн</b> — это типовое решение для часто встречающейся задачи при создании программ. Они испльзуются для проектирования и структуризации программы.</LI>
        <UL>
            <LI><b>Фасад (Facade)</b> - абстрагирует работу с несколькими классами, объединяя их единым интерфейсом взаимодействия.</LI>
            <LI><b>Стратегия (Strategy)</b> - используется для семейства схожих алгоритмов. Позволяет выбирать алгоритм путём определения соответствующего класса.</LI>
            <LI><b>Прокси/Заместитель (Proxy)</b> -  является посредником между двумя другими объектами, и который реализует/ограничивает доступ к объекту, к которому обращаются через него.</LI>
            <LI><b>Шаблонный метод (Template method)</b> - определяет основу алгоритма и позволяет наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом.</LI>
            <LI><b>Шаблон делегирования (Delegation pattern)</b> - выражает некоторое поведение, но в реальности передаёт ответственность за выполнение этого поведения связанному объекту. <i>Поддерживается Kotlin нативно, через "Делегированные свойства"</i></LI>
            <LI><b>Одиночка (Singleton)</b> - такой класс, может иметь только один экземпляр. Конструктор приватный, можно получить ссылку на объект через соответствующий метод.</LI>
        </UL>
    </UL>
</details>

### **8. Чем отличается Java от Kotlin?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>Меньше кода = быстрее разработка.</LI>
        <LI>Null Safety для исключений NullPointerExcpetion из Java.</LI>
        <LI>Расширение класса без наследования.</LI>
        <LI>Data-класс, для хранения данных, компилятор сгенерирует методы HashCode(), toString(), equal()/==.</LI>
    </UL>
</details>

### **9. Что такое корень приложения?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Корень приложения</b> - используемый для сборщика мусора, обзначаемая точка, с которой начинается поиск связанных с приложением объектов.<br><br>Корень приложения может включать в себя следующие элементы:
        <UL>
          <LI>Стек вызовов (Call Stack);</LI>
          <LI>Статические переменные (Static Variables);</LI>
          <LI><i>Ссылки на локальные переменные в нативном коде (JNI References);</LI>
          <LI>Специальные структуры данных JVM (JVM Special Data Structures)</i></LI>
        </UL>
        </LI>
    </UL>
</details>

## **Алгоритмы**

#### [Содержание<---](#содержание)

### **1. Что такое алгоритм и как выбрать правильный?**

### **2. Что такое сложность алгоритма? Как и с помощью чего её можно вычислить?**

### **3. Что такое нотация big-O?**

### **4. Что такое рекурсия?**

### **5. Какие алгоритмы сортировки вы знаете?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Быстрая</b></LI>
        <LI><b>Слиянием</b></LI>
        <LI><b>Пузырькем</b></LI>
        <LI><b>Поразрядная</b></LI>
    </UL>
</details>

## **Структуры данных ([Шпаргалка по структурам данных в Java](https://habr.com/ru/articles/751648/))**

#### [Содержание<---](#содержание)

### **1. Расскажите о таких структурах данных, как List, Set, Map?**

### **2. Какая разница между ArrayList и LinkedList?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>Аналогично с Array и List.</LI>
    </UL>
</details>

### **3. Что такое HashMap & TreeMap?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>HashMap:</b></LI>
        <UL>
          <LI>Основана на хеш-таблице.</LI>
          <LI>Позволяет быстро получать доступ к элементам по ключу (средняя сложность доступа O(1)).</LI>
          <LI>Не гарантирует порядок элементов.</LI>
          <LI>Может содержать null в качестве ключа или значения.</LI>
          <LI>Не является потокобезопасной, но может быть синхронизирована вручную или с использованием коллекции Collections.synchronizedMap().</LI>
        </UL>
        <LI><b>TreeMap:</b></LI>
        <UL>
          <LI>Основана на красно-черном дереве.</LI>
          <LI>Элементы хранятся отсортированными по ключу (естественный порядок или с помощью компаратора).</LI>
          <LI>Позволяет получать подмножество ключей и значений в определенном диапазоне.</LI>
          <LI>Поиск элементов выполняется за время O(log n).</LI>
          <LI>Не допускает null в качестве ключа, но может содержать null в качестве значения.</LI>
          <LI>Не является потокобезопасной, но может быть синхронизирована вручную или с использованием коллекции Collections.synchronizedSortedMap().</LI>
        </UL>
    </UL>
</details>

### **4. Что такое хеш-таблица?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Хеш-таблица</b> - это структура данных, используемая для реализации ассоциативного массива или словаря, где данные хранятся в виде пар ключ-значение. Она основана на идее хеширования, которое позволяет эффективно добавлять, удалять и искать элементы.</LI>
    </UL>
</details>

## **Хранение данных**

#### [Содержание<---](#содержание)

### **1. Как можно хранить данные в Android?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>SharedPreference</b> - хранение небольших объемов данных в виде пар ключ-значение. Отлично подходит для хранения настроек приложения.</LI>
        <LI><b>Файлы.</b></LI>
        <LI><b>SQLite</b> - легковесная реляционная база данных, встроенная в Android.Используется для хранения структурированных данных, таких как списки контактов, журналы и другие.</LI>
        <LI>Внешние службы хранения данных (Firebase Realtime Database, ...).</LI>
        <LI>DataStore (Part of Android Jetpack)</LI>
    </UL>
</details>

### **2. Когда следует использовать SharedPreferences?**

### **3. Из каких компонентов состоит библиотека [Room](https://developer.android.com/jetpack/androidx/releases/room)?**

### **4. Что такое @PrimaryKey, @Ignore, @Embedded, @TypeConverters в Room?**

### **5. Для чего нужна миграция в базах данных?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>- Применятся для переноса данных из текущей БД в новую без потери данных.</LI>
    </UL>
</details>

## **Работа с сетью**

#### [Содержание<---](#содержание)

### **1. Что такое JSON, XML?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>JSON</b> – это текстовый формат обмена данными, основанный на языке JavaScript. Используется для хранения примитивных типов данных.</LI>
        <LI><b>XML</b> – это расширяемый язык разметки. Поддерживает более сложные типы данных (изображения, даты, ...)</LI>
    </UL>
</details>

### **2. Какие варианты реализации работы с сервером?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>HTTP-запросы (GET, POST, PUT, ...)</LI>
        <LI>WebSocket</LI>
        <LI>RESTful API</LI>
    </UL>
</details>

### **3. Что такое REST?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>REST (Representational State Transfer)</b> - это архитектурный стиль, используемый для создания веб-сервисов. Он определяет набор правил и ограничений для создания API, которые позволяют клиентам выполнять операции CRUD (Create, Read, Update, Delete) с ресурсами на сервере.
Система разделена на клиентов и серверы, которые независимо развиваются и могут изменяться без влияния на другую сторону. Все ресурсы в системе должны быть доступны через унифицированный интерфейс, который включает в себя стандартные методы HTTP (GET, POST, PUT, DELETE) и правильное использование HTTP статусных кодов.</LI>
    </UL>
</details>

### **Что такое сериализация и десериализация?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Сериализация</b> - процесс преобразования объекта или структуры данных из их внутреннего представления в формат, который можно сохранить или передать через сеть. Например, объекты данных в вашем приложении могут быть сериализованы в JSON или бинарный формат для сохранения на диске или передачи по сети.</LI>
        <LI><b>Десериализация</b> - обратный процесс - восстановление объекта или структуры данных из сохраненного или переданного формата обратно в их внутреннее представление. Например, когда вы загружаете JSON-строку с сервера, вам нужно десериализовать ее обратно в объекты данных, которые ваше приложение может использовать.</LI>
    </UL>
</details>

## **Многопоточность**

#### [Содержание<---](#содержание)

### **1. Что такое процесс?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Процесс</b> - экземпляр исполняемой программы, под который были выделени ресурсы системы. Процесс ограничен адресным просранством и изначально не имеет доступ к переменным или структурам другого процесса.</LI>
    </UL>
</details>

### **2. Что такое поток?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Поток</b> - способ исполнения процесса, он находится в том же пространстве, что и процесс, но имеет доступ к другим потокам. Если поток изменил ресурс процесса, эти изменения видны для других потоков, дополнительно могу отметить, что каждый поток имеет свой стэк в рамках процесса, но также имеет доступ к стэкам и других потоков.</LI>
    </UL>
</details>

### **3. Для чего используют ключевое слово synchronized?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>Т.к. потоки работают независимо друг от друга, то может возникнуть ситуация, когда ресурс изменяется сразу несколькими потоками, к примеру вывод в консоль. I поток вывет свой код, а II поток выведет свой, в итоге они сольются.<br>
        Чтобы такая ситуация не возникала используются Mutex'ы.
        <UL>
            <LI><b>Mutex</b> ограничивает доступ к объекту в опредленное время для других потоков, если его уже взял какой-либо поток. Доступ будет открыт только после того, как взявший его поток закончит работу.</LI>
            <LI><b>Ключевое слово synchronized</b> используется для пометки метода или объекта. Если один поток зашел внутрь блока кода, который помечен словом synchronized, он моментально захватывает мьютекс объекта, и все другие потоки, которые попытаются зайти в этот же блок или метод вынуждены ждать, пока предыдущий поток не завершит свою работу и не освободит mutex.</LI>
        </UL>
        </LI>
    </UL>
</details>

### **4. Зачем синхронизировать потоки?**

### **5. Какая разница между синхронным и асинхронным исполнением?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Синхронное исполнение</b></LI>
        <UL>
            <LI>Задачи исполняются последовательно, одна за другой.<br>Порядок исполнения = порядку вызова.</LI>
            <LI>Исполняемая в момент задача блокирует выполнение следующей, соответственно вызываемый поток будет ожидать завершения задачи.</LI>
        </UL>
        <LI><b>Асинхронное исполнение</b></LI>
        <UL>
            <LI>Задачи выполняются разрознено без ожидания завершения других задач.</LI>
            <LI>Используется для выполнения длительных задач в фоне, без остановки основного потока(приложения).</LI>
        </UL>
    </UL>
</details>


### **6. Как мы можем создать поток в Java?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>От класса Thread можно наследоваться и описать исполнения какого-либо процесса в блоке метода <b><i>run()</b></i></LI>
    </UL>
</details>

### **7. Как мы можем создать поток в Kotlin?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Использование корутин (Coroutines)</b><br><b>Coroutines</b> - это легковесные потоки, которые не блокируют основной поток выполнения.</LI>
        <UL>
            <LI>Для испльзования корутин, нужно определить <b>область корутин</b>.
            <UL>
                <LI><b>GlobalScope</b> - глобальная область, которая доступна на протяжении всего жизненного цикла приложения. Соответственно является областью всего kotlin приложения.</LI>
                <LI><b>CoroutineScope</b> - локальная область, доступна только в рамках какого-либо компонента приложения.</LI>
                <UL>
                    <LI><b>ViewModelScope</b> - область, предназначенная для использования в архитектуре приложений, основанных на  архитектурном компоненте ViewModel из Android Jetpack. Эта область корутины автоматически отменяется при уничтожении ViewModel</LI>
                </UL>
                <LI><i>Чтобы в указанной области запустить корутину, функция должна быть помечана как <code>suspend</code></i><br>При определении (<code>fun getUsers(): Flow&lt;String&rt;</code>) функции-потока (в данном случае функции getUsers) необязательно использовать модификатор suspend.</LI>
            </UL>
        </UL>
        <LI><b>Использование асинхронных потоков (Flow)</b><br><b>Flow</b> - это интерфейс, для создания подобных потоков. По сути асинхронный поток - это объект Flow. Он типизируется (Flow < String > ) типом тех данных, которые должны передаваться в потоке.<br>Для создания объекта Flow применяется специальная функция <code><br>fun getUsers(): Flow<String> = flow {<br>&nbsp// создание асинхронного потока в функции flow<br>&nbspemit(item) // передаем значение в поток<br>}</code><br>Во внешнем коде в функции main вызываем функцию-поток getUsers(). Для управления объектами из потока для интерфейса Flow определен ряд функций, одной из которых является функция collect(). В качестве параметра она принимает функцию, в которую передает эмитируемый объект из потока. Так, в данном случае это просто функция вывода на консоль:<br><code>getUsers().collect { user -> println(user) }</code></LI>
    </UL>
</details>

### **8. Что такое deadlock?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>deadlock</b> - ситуация, когда потоки блокируются, что происхоит, к примеру, в следствии ситуации:
        <OL>
          <LI>Поток A захватывает ресурс X</LI>
          <LI>Поток B захватывает ресурс Y.</LI>
          <LI>Поток A пытается захватить ресурс Y, но он уже захвачен потоком B и ожидает его освобождения.</LI>
          <LI>Поток B пытается захватить ресурс X, но он уже захвачен потоком A и ожидает его освобождения.</LI>
        </OL>
        В итоге оба потока заблокированы и не могут продолжить выполнение, так как ожидают освобождения ресурсов, которые удерживают другие потоки.<br><br>
        Если deadlock не разрешается, программа останавливается и перестает отвечать, что может привести к нежелательным последствиям. Разрешение deadlock обычно включает в себя обнаружение циклических зависимостей ресурсов и прерывание блокировки для одного из потоков для разрыва замкнутого круга.
        </LI>
    </UL>
</details>

### **9. Какие варианты реализации многопоточности есть в Android?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>Класс 'Handler' и 'Looper' для управления потоками (Thread)</LI>
        <LI>Потоки (Thread), но создавать новые потоки напрямую сулит возможными ошибками, сложностями и опасностями, особенно при работе с пользовательским интерфейсом.</LI>
        <LI>Корутины (Kotlin Coroutines )</LI>
    </UL>
</details>

### **10. Что такое main thread? Какие операции нужно выполнять на main thread, а какие нельзя делать?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>main thread</b> - основной поток приложения, в котором обрабатываются изменения интерфейса, взаимодействие с ним от пользователя или системы. На этом потоке нельзя выполнять долгие операции, блокирующие операции, тяжелые (аычислительно интенсивные) операции.</LI>
    </UL>
</details>

### **11. Что такое ключевое слово atomic и для чего оно нужно?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Ключевое слово atomic</b> - относится к классу Atomic из пакета kotlinx.atomicfu. Этот класс предоставляет атомарные операции для многопоточного программирования.</LI>
        <UL><LI><b>Атомарная операция</b> либо выполняется как единое целое, либо не выполняется вообще, не допуская вмешательства других потоков между началом и завершением операции.</LI></UL><br>Атомарные операции позволяют выполнять некоторые операции над переменными в многопоточной среде таким образом, чтобы они гарантированно выполнялись как единое целое, без возможности вмешательства других потоков между началом и завершением операции.<br><br>В Kotlin Atomic предоставляет несколько методов для атомарных операций, таких как get, set, compareAndSet и другие. Эти операции обеспечивают безопасный доступ и изменение значений переменных в многопоточной среде.
    </UL>
</details>

## **Java Core**

#### [Содержание<---](#содержание)

### **1. Что такое Exceptions? Зачем они нужны?**

### **2. Зачем используют ключевые слова final, finally и finalize?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>final</b> - используется для создания неизменяемых переменных, констант и методов, а также для определения неизменяемых классов + класс не может быть наследован. </LI>
        <LI><b>finally</b> - используется в блоке try-catch-finally для выполнения кода независимо от того, возникло исключение или нет. Это используется, например, для освобождения ресурсов, закрытия файлов или соединений с базой данных, независимо от того, произошла ошибка или нет.</LI>
        <LI><b>finalize</b> - метод, который вызывается сборщиком мусора перед удалением объекта из памяти. <i>Использование не рекомендуется</i></LI>
    </UL>
</details>


### **3. Что такое абстрактный класс? Что такое интерфейс?**

### **4. Что такое анонимный класс? Использовали ли на практике? Для чего?**

### **5. Что такое статический класс (static class)?**

### **6. Что такое enum? Зачем его используют?**

### **7. Можем ли мы сделать конструктор приватным?**

### **8. Какая разница между ключевыми словами throw и throws?**

### **9. Какая разница между Error и Exception?**

### **10. Какая разница между checked и unchecked exception?**

### **11. Что такое Object class и какие методы он имеет?**

### **12. Какие существуют модификаторы доступа для классов? Какая разница между ними?**

### **13. Что такое итератор?**

### **14. Как безопасно удалить элемент из коллекции?**

### **15. Зачем нам переопределять equals() и когда не нужно это делать?**

### **16. Какой должен выполняться контракт при переопределении equals()?**

## **RxJava**

#### [Содержание<---](#содержание)

### **1. В чем разница между map() и flatMap() в RxJava?**

### **2. Когда используете observeOn(), а когда subscribeOn()?**

### **3. Как можно обработать ошибки в RxJava?**

### **4. Какие schedulers знаете в RxJava? Назовите их отличия.**

### **5. Что такое Disposable? Зачем его используют?**

### **6. В чем разница между Hot и Cold Observables? Назовите примеры в RxJava.**

## **Android SDK**

#### [Содержание<---](#содержание)

### **1. Какие базовые Android-компоненты можете назвать?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Activity</b> - представляет экран с пользовательским интерфейсом. Она является основным способом взаимодействия пользователя с приложением.</LI>
        <LI><b>Service</b> - компонент, который выполняет операции, необходимые для работы в фоновом режиме, даже когда пользователь не активен. Например, сервис может проигрывать музыку, загружать файлы или выполнять другие <b>длительные операции</b>.</LI>
        <LI><b>BroadcastReceiver</b> - обрабатывает системные объявления (broadcasts) о различных событиях, таких как получение SMS, подключение к сети и другие. Он может запускаться даже в том случае, если приложение не активно.</LI>
        <LI><b>ContentProvider</b> - единый интерфейс для управления данными приложения, такими как базы данных SQLite, файлы и другие. Он используется для обмена данными между различными приложениями Android.</LI>
    </UL>
</details>

### **3. Что такое Activity?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Activity</b> является основным компонентом пользовательского интерфейса в приложении Android и предоставляет окно для размещения интерфейса пользователя, такого как элементы управления, изображения, текст и другие виджеты. Кроме того, Activity может взаимодействовать с другими компонентами Android, такими как другие Activity, Fragment, Service и BroadcastReceiver.</LI>
    </UL>
</details>

### **4. Опишите жизненный цикл Activity.**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>onCreate(Bundle saveInstanceState)</LI>
        <LI>onStart()</LI>
        <LI><i>onPause()</i></LI>
        <LI><i>onResume()</i></LI>
        <LI>onStop()</LI>
        <LI>onDestroy()</LI>
    </UL>
</details>

### **4. Что такое  Bundle saveInstanceState в методе onCreate?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
      <LI><b>savedInstanceState</b> - это объект класса Bundle, который содержит состояние предыдущего экземпляра активности, которое было сохранено при ее уничтожении. Этот Bundle обычно используется для восстановления данных после пересоздания активности.</LI>
      <UL>
        <LI><b>Класс Bundle</b> -  в Android используется для передачи данных между компонентами приложения, такими как активности, фрагменты и службы. Он представляет собой контейнер для пар "ключ-значение", где ключи являются строками, а значения могут быть различных типов данных, таких как строки, целые числа, массивы и др.</LI>
      </UL>
      Если активность создается впервые (например, при запуске приложения), savedInstanceState будет null. Однако, если активность была уничтожена и пересоздана, savedInstanceState будет содержать сохраненное состояние, которое можно использовать для восстановления данных и состояния активности.
    </UL>
</details>

### **5. Какие типы Service знаете?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Foreground Service (Служба в первом плане)</b>: Этот тип службы используется для выполнения операций, которые должны оставаться видимыми для пользователя. Например, служба проигрывания музыки или загрузки файлов. Foreground Service обычно связан с уведомлением, чтобы пользователь знал, что приложение продолжает работать.</LI>
        <LI><b>Background Service (Служба в фоне)</b>: Этот тип службы выполняется в фоновом режиме и не отображает уведомлений пользователю. Обычно используется для выполнения операций, которые могут быть завершены после того, как пользователь покинет приложение.</LI>
        <LI><b>Bound Service (Привязанная служба)</b>: Этот тип службы используется для связи между компонентами Android, такими как активности и службы. Активность может связаться с привязанной службой, чтобы отправлять запросы и получать ответы. Привязанная служба останавливается, когда последний компонент, связанный с ней, отвязывается.</LI>
    </UL>
</details>

### **6. Что такое BroadcastReceiver и какие типы существуют?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>BroadcastReceiver в Android</b> - это компонент приложения, который позволяет приложению реагировать на широковещательные сообщения (broadcast messages) от системы, других приложений или самого приложения. BroadcastReceiver реализует обработчик, который выполняется при получении определенного типа широковещательного сообщения.</LI>
        <UL>
          <LI><b>Статический (Static)</b>: Определяется в манифесте приложения с использованием тега <receiver>. Этот тип BroadcastReceiver запускается системой Android, даже если приложение не активно.</LI>
          <LI><b>Динамический (Dynamic)</b>: Создается и регистрируется во время выполнения приложения с помощью метода registerReceiver() в коде приложения. Этот тип BroadcastReceiver существует только во время выполнения активности или службы, которая его зарегистрировала, и будет автоматически отменен при уничтожении контекста, который его зарегистрировал.</LI>
        </UL>
    </UL>
</details>

### **7. Что такое ContentProvider?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>ContentProvider</b> - это компонент, который предоставляет унифицированный способ для управления и обмена данными между различными приложениями в рамках операционной системы Android. Он предоставляет доступ к структурированным данным приложения через интерфейс URI. ContentProvider может быть использован для доступа к данным из базы данных, файловой системы, интернета и других источников.</LI>
    </UL>
</details>

### **8. Что такое Фрагмент? Для чего используют механизм фрагментов?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Фрагмент (Fragment)</b> - составная часть интерефейса (Activity)<br>Используется для повторного использования, создания адаптивного дизайна.</LI><br>
        Основные цели использования фрагментов включают:
        <UL>
          <LI><b>Модульность и повторное использование;</b></LI>
          <LI><b>Поддержка различных форм-факторов устройств;</b></LI>
          <LI><b>Многозадачность и параллельное выполнение;</b></LI>
          <LI><b>Динамическое управление интерфейсом.</b></LI>
        </UL>
    </UL>
</details>

### **9. Опишите жизненный цикл Fragment.**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>onAttach() - связывается с Activity</LI>
        <LI>onCreate()</LI>
        <LI>onCreateView()</LI>
        <LI>onActivityCreate()</LI>
        <LI>onStart()</LI>
        <LI>onResume()</LI>
        <LI>onPause()</LI>
        <LI>onStop()</LI>
        <LI>onDestroyView()</LI>
        <LI>onDestroy()</LI>
        <LI>onDetach()</LI>
    </UL>
</details>


### **10. Есть ли у Fragment контекст? Если да, то как его получить?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>Context fragment привязан к контексту Activity, соответственно при попытке получить его, стоит ожидать контекст связанной активити. Получить его можно через метод <code>getContext()</code>.</LI>
    </UL>
</details>


### **11. Чем отличается Fragment от Activity? Зачем выдумали Fragment?**

### **12. Что такое изменение конфигурации? Что происходит с приложением на Android при этом?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>ЖЦ всех связанный объектов будет начат с начала. (onCreate будет вызван еще раз)</LI><br>
        Смена локалей / поворот устройства
    </UL>
</details>


### **13. Что такое Intent? Что такое explicit/implicit Intent?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Intent в Android</b> - это объект, который представляет собой абстракцию операции, которая должна быть выполнена. Он обычно используется для перехода от одной активности (Activity) к другой, запуска службы (Service), отправки широковещательного сообщения (Broadcast), а также для связывания компонентов приложения.</LI>
        <UL>
          <LI><b>Явный (explicit) Intent</b> - это интент, который явно указывает компонент (Activity, Service, BroadcastReceiver) приложения, который должен быть запущен или связан. Например, если вы хотите запустить новую активность, вы указываете класс этой активности в явном Intent.</LI>
          <LI><b>Неявный (implicit) Intent</b> - это интент, который не указывает конкретного компонента, который должен быть запущен или связан. Вместо этого он указывает на определенное действие, которое должно быть выполнено, и система Android выбирает подходящий компонент для его обработки на основе фильтров Intent, объявленных в манифесте приложения другими компонентами. Например, если вы хотите открыть веб-страницу в браузере, но не знаете, какой браузер используется, вы можете использовать неявный Intent.</LI>
        </UL>
    </UL>
</details>


### **14. Что такое SharedPreferences?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>SharedPreferences</b> - постоянное хранилище на платформе Android. Применяются для хранения конфигурации приложения. По своей сути представляет из себя XML-файл, где данные хранятся парами (ключ, занчение). Файл хранится в /data/shared_prefs.<br>Получить экземпляр SharedPreferences можно от Context.getSharedPreferences(name = "имя_файла_с_настройками", mode = Context.MODE_XXXX).</LI>
        <UL>
        <LI><b>MODE_PRIVATE</b> - доступ только у приложения владельца</LI>
        <br>Остальные методы помечены как <b>deprecated</b>
        <LI><b><i>MODE_WORLD_READABLE</i></b> - только чтение</LI>
        <LI><b><i>MODE_WORLD_WRITEABLE</i></b> - только запись</LI>
        <LI><b><i>MODE_MULTI_PROCESS</i></b> - доступ к файлу имеют несколько процессов</LI>
        </UL>
    </UL>
</details>


### **15. Что такое ANR? Как избегать таких ситуаций?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>ANR (Application Not Response)</b> - приложение не отвечает. Может возникнуть, если вызвать delay в main потоке и других случаях, когда следует использовать отличный поток от main thread.</LI>
    </UL>
</details>


### **16. Что такое DataBinding?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Data Binding (Привязка данных)</b> - это библиотека, которая позволяет связывать данные в приложении с элементами пользовательского интерфейса без необходимости явного обращения к ним через их идентификаторы.</LI>
    </UL>
</details>


### **17. Что такое LiveData? Какие виды знаете?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>LiveData</b> - хранилище данных, работающее по принципу паттерна Observer (наблюдатель). В него можно поместить какой-либо объект и также на него можно подписаться и получать объекты, которые в него помещают.</LI>
    </UL>
</details>


### **18. Как создать ViewModel? Почему создавать ViewModel нужно именно так?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Неправильно</b> - просто в val вызвать конструктор.</LI>
        <LI><b>Правильно</b> - через ViewModelProvider</LI>
        <br>
        <LI>Чтобы жизненный цикл VM продолжался до полного закрытия приложения.</LI>
    </UL>
</details>


### **19. Что такое Context и зачем он?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Context</b> – это объект, который предоставляет доступ к базовым функциям приложения: доступ к ресурсам, к файловой системе, вызов активности и т.д. </LI>
        <LI>В свою очередь Context имеет свои методы, позволяющие получать доступ к ресурсам и другим объектам.</LI>
        <UL>
          <LI><code>getAssets()</code></LI>
          <LI><code>getResources()</code></LI>
          <LI><code>getPackageManager()</code></LI>
          <LI><code>getString()</code></LI>
          <LI><code>getSharedPrefsFile()</code></LI>
        </UL>
    </UL>
</details>


### **20. Что такое AndroidManifest.xml? Зачем его используют? Что мы можем там декларировать?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>AndroidManifest.xml</b> - обязательный файл для каждого приложения на платформе Android. Он содержит важную метаинформацию о приложении и необходим для правильной работы приложения на устройствах Android. Вот основные его функции:</LI>
        <OL>
        <LI><b>Описание приложения:</b> В файле AndroidManifest.xml содержится информация о приложении, такая как его название, версия, пакетное имя, иконка приложения и другие основные атрибуты.</LI>
        <LI><b>Компоненты приложения:</b> Здесь декларируются все компоненты приложения, такие как активности (&lt;activity&gt;), службы (&lt;service&gt;), приемники широковещательных сообщений (&lt;receiver&gt;) и провайдеры контента (&lt;provider&gt;). Это позволяет системе Android знать о наличии и структуре компонентов приложения.</LI>
        <LI><b>Разрешения:</b> В <code>AndroidManifest.xml</code> указываются разрешения, необходимые для доступа к различным системным ресурсам и функциям устройства, таким как доступ к интернету, камере, геолокации и другим. Это позволяет пользователям заранее знать, какие разрешения запрашивает приложение, и контролировать их предоставление.</LI>
        <LI><b>Фильтры намерений (Intent filters):</b> С помощью элементов &lt;intent-filter&gt; можно указать, какие действия (intent) компонент приложения может обрабатывать. Например, здесь определяются активности, которые должны быть запущены при определенных действиях пользователя или системы, таких как открытие определенного типа файлов или ссылок.</LI>
        <LI><b>Метаинформация:</b> В файле AndroidManifest.xml можно также задать дополнительную метаинформацию о приложении, такую как минимальная версия Android, необходимая для запуска приложения, описание, категории приложения и другие дополнительные атрибуты.</LI>
        </OL>
    </UL>
</details>

### **21. Перечислите известные layout и их краткое описание.**
<details>
  <summary><b>Answer</b></summary>
    <OL>
        <LI><b>LinearLayout:</b></LI>
          <UL>
            <LI>Это простой макет, который располагает свои дочерние элементы в одной строке или одном столбце.</LI>
            <LI>Может быть горизонтальным или вертикальным.</LI>
            <LI>Управляет расположением элементов с помощью атрибутов layout_weight и layout_gravity.</LI>
          </UL>
        <LI><b>RelativeLayout:</b></LI>
          <UL>
            <LI>Позволяет размещать дочерние элементы относительно друг друга или относительно родительского контейнера.</LI>
            <LI>Эффективен для создания сложных макетов, где требуется контроль над расположением элементов.</LI>
          </UL>
        <LI><b>ConstraintLayout:</b></LI>
          <UL>
            <LI>Это гибкий макет, который использует ограничения для определения позиций и размеров дочерних элементов относительно друг друга и родительского контейнера.</LI>
            <LI>Позволяет создавать сложные и адаптивные макеты с минимальным использованием вложенных виджетов.</LI>
          </UL>
        <LI><b>FrameLayout:</b></LI>
          <UL>
            <LI>Простой макет, который размещает все свои дочерние элементы в одной области, накладывая их друг на друга.</LI>
            <LI>Используется часто для создания простых макетов и для отображения одного элемента поверх другого, например, для создания слоя с фоном и слоя с контентом.</LI>
          </UL>
        <LI><b>GridLayout:</b></LI>
          <UL>
            <LI>Располагает свои дочерние элементы в виде сетки с заданным количеством строк и столбцов.</LI>
            <LI>Эффективен для создания макетов, где требуется равномерное размещение элементов.
</LI>
          </UL>
        <LI><b>CoordinatorLayout:</b></LI>
          <UL>
            <LI>Это расширенный макет, который обычно используется вместе с виджетами Material Design для реализации сложных взаимодействий между элементами пользовательского интерфейса.</LI>
          </UL>
    </OL>
</details>

### **22. Расскажите, что нужно реализовать, чтобы отобразить список строк в RecyclerView.**

### **23. Объясните паттерн ViewHolder. Для чего он применяется?**

### **24. Что такое DiffUtil?**

### **25. Расскажите о ConstraintLayout.**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>ConstraintLayout</b> представляет контейнер, который позволяет создавать гибкие и масштабируемые визуальные интерфейсы.<br><br>Для позиционирования элемента внутри ConstraintLayout необходимо указать ограничения (constraints). Есть несколько типов ограничений. В частности, для установки позиции относительно определенного элемента испльзуются ограничения.</LI>
    </UL>
</details>

### **26. Для чего используют Group, Guideline, Barriers, Chains в ConstraintLayout?**

### **27. У вас есть Activity с двумя Fragment'ами, у одного есть кнопка, у другого TextView. При нажатии кнопки изменяется TextView. Как вы реализуете это?**
<details>
  <summary><b>Answer</b></summary>
    <OL>
        <LI>Использование интерфейса для обратного вызова: Создайте интерфейс, который будет оповещать Activity о событиях, происходящих в первом фрагменте.</LI>
        <LI>Реализация интерфейса в Activity: В вашей Activity реализуйте этот интерфейс и определите метод, который будет вызываться при нажатии кнопки в первом фрагменте. В этом методе вы можете получить ссылку на второй фрагмент и обновить его TextView.</LI>
        <LI>Вызов метода интерфейса из первого фрагмента: В вашем первом фрагменте вызовите метод интерфейса, когда кнопка будет нажата.</LI>
        <LI>Обновление TextView второго фрагмента: В вашем втором фрагменте определите метод для обновления TextView и вызовите его из Activity.</LI>
    </OL>
</details>

### **28. Что такое WorkManager? Когда используем?**

## **Kotlin**

#### [Содержание<---](#содержание)

### **1. Как вы понимаете термин Null safety?**

### **2. Что такое nullable, non-nullable и platform типы? Какая разница между val и var?**

### **3. Как задекларировать getter/setter для property?**
<details>
  <summary><b>Answer</b></summary>
    <pre><code><span style="color:orange;">var</span> myProperty: Int
  <span style="color:orange;">get</span>() = field * 2
  <span style="color:orange;">set</span>(value) {
    field = value / 2
  }</pre></code>
</details>

### **4. Почему классы Kotlin по умолчанию final?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>Часть философии безопасного программирования в Kotlin.</LI>
    </UL>
</details>


### **5. Что такое sealed class?**

### **6. Что такое data class?**

### **7. Какая разница между sealed class и enum?**

### **8. Почему у Kotlin нет checked exceptions?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>Это философи языка. Они будут выброшены только в рантайме, а компилятор их пропустит, в сравнении с Java подобные исключения нужно будет обработать в коде.</LI>
    </UL>
</details>

### **9. Что такое Extensions (расширение)? Использовали ли вы их на практике?**

### **10. Что такое перегрузка операторов (operator overloading)? Зачем нужен этот механизм?**

### **11. Как работают примитивы в Kotlin?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>Kotlin автоматически выполняет упаковку (boxing) примитивных типов данных в объекты при необходимости их использования в контексте, где требуется объект. Если объект никогда не принимает значение null, Kotlin может использовать прямое представление примитивного типа данных без его обертки. Также существует явные функции преобразования между примитивными типами данных и их обертками.</LI>
    </UL>
</details>

### **12. Расскажите об объекте Unit в Kotlin.**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Unit = void</b></LI>
        <LI><b>Функциональный тип.</b> Функциональные типы объявляются с использованием синтаксиса <code>(параметры) -> возвращаемый_тип</code></LI>
    </UL>
</details>


### **13. Расскажите об объекте Any в Kotlin.**

### **14. Как создать Singleton объект в Kotlin?**
<details>
<summary><b>Answer</b></summary>
<UL><LI><b>С использованием object:</b><br><br>
<pre><code><span style="color:orange;">object</span> MySingleton {
  <span style="color:orange;">init</span> {
    println(<span style="color:green;">"Singleton initialized"</span>)
  }
  <span style="color:orange;">fun</span> doSomething() {
    println(<span style="color:green;">"Singleton function called"</span>)
  }
}
<span style="color:gray;">// Использование синглтона</span>
MySingleton.doSomething()</pre></code></LI>
<LI><b>С использованием companion object:</b><br><br>
<pre><code><span style="color:orange;">class</span> MySingleton <span style="color:orange;">private constructor</span>() {
  <span style="color:orange;">companion object</span> {
      <span style="color:orange;">private val</span> <span style="color:MediumOrchid;">instance</span>: MySingleton <span style="color:orange;">by</span> lazy { MySingleton() }
    <span style="color:orange;">fun</span> <span style="color:DodgerBlue;">getInstance</span>(): MySingleton {
      <span style="color:orange;">return</span> <span style="color:MediumOrchid;">instance</span>
    }
  }
  <span style="color:orange;">init</span> {
    println(<span style="color:green;">"Singleton initialized"</span>)
  }
  <span style="color:orange;">fun</span> doSomething() {
    println(<span style="color:green;">"Singleton function called"</span>)
  }
}

<span style="color:gray;">// Использование синглтона</span>
<span style="color:orange;">val</span> singleton = MySingleton.getInstance()
singleton.doSomething()</pre></code></UL></details>

### **15. Что такое companion object?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>companion object = static</b></LI>
    </UL>
</details>

### **16. Чем отличается const val от val?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>const val</b> инициализируется значением на этапе компиляции</LI>
        <LI><b>val</b>  вычисляются во время выполнения программы</LI>
    </UL>
</details>

### **17. Какие знаете модификаторы доступа?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>дефолтные + internal</b></LI>
    </UL>
</details>

### **18. Что означает модификатор lateinit?**

### **19. Coroutines – что это за механизм? Использовали ли его на практике?**

### **20. Зачем нужны Coroutines? Чем они лучше обычных тредов?**

### **21. Что такое suspend-функция?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>suspend(рус. приостановить)</b></LI>
    </UL>
</details>

### **22. Что такое Job?**
<details>
  <summary><b>Основные методы</b></summary>
    <UL>
        <LI>start() - запускает выполнение задачи.</LI>
        <LI>cancel() - отменяет выполнение задачи.</LI>
        <LI>join() - блокирует текущий поток до завершения выполнения задачи.</LI>
        <LI>isActive - свойство, которое показывает, активна ли задача (не отменена и не завершена).</LI>
        <LI>isCancelled - свойство, которое показывает, отменена ли задача.</LI>
        <LI>isCompleted - свойство, которое показывает, завершена ли задача.</LI>
    </UL>
</details>

### **23. Что такое Dispatcher? Какие есть виды?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Dispatcher</b> - это компонент, управляющий тем, на каком потоке или пуле потоков выполняются корутины. Он определяет контекст выполнения для корутины, включая то, на каком потоке она будет запущена и продолжена после приостановки.</LI>
        <OL>
          <LI><b>Dispatchers.Default:</b> Предназначен для CPU-интенсивных операций. Использует пул потоков размером, соответствующим числу процессоров, доступных в системе. По умолчанию используется 1 или (число ядер CPU - 1) потоков.</LI>
          <LI><b>Dispatchers.IO:</b> Предназначен для операций ввода-вывода (I/O), таких как чтение/запись файлов, сетевые запросы и т. д. Использует пул потоков с переменным размером, который автоматически масштабируется в зависимости от нагрузки.</LI>
          <LI><b>Dispatchers.Main:</b> Для использования в Android. Он позволяет выполнять корутины на основном потоке пользовательского интерфейса (UI), что позволяет обновлять пользовательский интерфейс из фоновых задач.</LI>
          <LI><b>Dispatchers.Unconfined:</b> Позволяет выполнить корутину без привязки к конкретному потоку. Корутина будет начата в текущем потоке, но после приостановки может быть возобновлена в любом потоке.</LI>
        </OL>
    </UL>
</details>

### **24. Что такое Scope?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Scope (область)</b>- это контекст выполнения для корутин. Scope определяет, когда корутина должна быть активной и когда она должна завершиться.<br><br>Корутины могут быть запущены в рамках определенной области, которая может быть ограничена временем жизни, потоком выполнения или другими факторами. Scope управляет жизненным циклом корутины, позволяя ей быть активной в течение определенного периода времени.</LI>
    </UL>
</details>

### **25. Что такое Generics?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Generics (Обобщения)</b> - механизм, который позволяет создавать классы, интерфейсы и методы, которые могут работать с любым типом данных, а не только с конкретным типом. Они обеспечивают типовую безопасность и повышают переиспользуемость кода.</LI>
    </UL>
</details>

### **26. Что такое Wildcard?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Wildcard</b> - относится к использованию символа вопросительного знака (?) Generics. Этот символ обозначает неопределенный тип.</LI>
        <UL>
          <LI><b>Ограниченный wildcard SomeCollection&lt;*> (bounded wildcard):</b><br>В этом примере SomeCollection<*> означает, что объект может принимать SomeCollection любого типа, но без возможности изменения элементов.</LI>
          <LI><b>Ограниченный wildcard с верхней границей &lt;out Number> (upper bounded wildcard):</b><br>В этом примере SomeCollection<*> означает, что объект может принимать SomeCollection любого типа, который является подтипом Number, но не обязательно самим Number.</LI>
          <LI><b>Ограниченный wildcard с нижней границей &lt;in String> (lower bounded wildcard):</b><br>В этом примере SomeCollection<*> означает, что объект может принимать SomeCollection любого типа, который является супертипом String, но не обязательно самим String.</LI>
        </UL>
    </UL>
</details>

### **27. Более подробно про ключевые слова in и out.**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>in (обозначает контравариантность):</b></LI>
        <UL>
          <LI>Ключевое слово in указывает, что тип является "входящим" в обобщенном типе, то есть он может использоваться только в качестве входных параметров функции (производит данные).</LI>
          <LI>Например, List<in String> означает, что список может содержать элементы типа String и его супертипы.</LI>
          <LI>Это полезно, когда вам нужно передать в функцию контейнер, из которого вы только читаете данные.</LI>
        </UL>
        <LI><b>out (обозначает ковариантность):</b></LI>
        <UL>
          <LI>Ключевое слово out указывает, что тип является "выходящим" из обобщенного типа, то есть он может использоваться только в качестве выходных параметров функции (потребляет данные).</LI>
          <LI>Например, List<out String> означает, что список может содержать элементы типа String и его подтипы.</LI>
          <LI>Это полезно, когда вам нужно вернуть из функции контейнер, в который вы только что положили данные.</LI>
        </UL>
    </UL>
</details>

### **28. Что такое iner class и для чего он используется?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Inner class (внутренний класс)</b> - класс, который определен внутри другого класса. Внутренний класс имеет доступ ко всем членам внешнего класса, включая закрытые и защищенные члены.<br><br>Это может быть удобно, когда вам нужен доступ к членам внешнего класса изнутри внутреннего класса.</LI>
    </UL>
</details>

### **29. Что такое data class?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>data class (класс данных)</b> используется для хранения данных. Автоматически генерируются следующие методы:</LI>
        <UL>
        <LI><b>toString</b> - для представления объекта в виде строки.</LI>
        <LI><b>equals</b> -  для сравнения объектов на равенство.</LI>
        <LI><b>hashCode</b> - для вычисления хеш-кода объекта.</LI>
        <LI><b>copy</b> - для создания копии объекта с возможностью изменения его свойств.</LI>
        </UL>
        Также компилятор автоматически генерирует конструктор, который принимает все свойства класса в качестве параметров.<br><br>Если в классе данных определены свойства, они автоматически генерируют геттеры и (при необходимости) сеттеры.<br><br>Наследование от класса данных в Kotlin ведет себя так же, как и для обычных классов. Если класс-потомок наследует класс-данных, то он унаследует все свойства и методы родительского класса, включая сгенерированные методы, такие как toString(), equals(), hashCode() и copy(). Однако для потомка не будут автоматически сгенерированы эти методы, они будут использовать те, которые уже определены в родительском классе.
    </UL>
</details>

## **Другое**

#### [Содержание<---](#содержание)

### **1. Расскажите, что такое memory leak. Как избежать?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **2. Как бы вы искали memory leak?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **3. Расскажите о Dependency injection. Какие варианты реализации в Android?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **4. Для чего нужна система контроля версий?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **5. Что такое Git?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **6. Для чего используем .gitignore-файл?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **7. Расскажите о командах push, pull, fetch в Git?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **8. Что такое merge и rebase? Какая разница?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **9. Что такое CI? Зачем используем?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


## **Практические задачи**

#### [Содержание<---](#содержание)

### **1. Разверните Linked List. Отпишите о зацикленности в LinkedList или ее отсутствии.**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **2. Напишите функцию, которая вернет n первых неотъемлемых чисел:**
```kotlin
un nMin(items: List<String>, n: Int): List<Int> {
//return n minimal non negative items
}

Пример вызова функции: nMin(listOf("1","-11","-12","22","100","-30",”2”, “5”), 3)

Ожидаемый результат: [1, 22, 100]
```
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **3. Что будет выведено в консоль? Объясните результат.**
```kotlin
var globalId = 0
data class User(val name: String) {
val id = globalId++
}
fun main(args: Array<String>) {
val user1 = User("User")
val user2 = User("User")
println(user1)
println(user2)
println(user1 == user2)
}
```
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>

### **4. Исправьте все ошибки в коде:**
```kotlin
class Animal
class Dog: Animal {}
```
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>

### **5. Для коллекции items:**
**Подсчитайте количество отрицательных элементов.
Вычислите среднее арифметическое значение отрицательных и неотрицательных чисел.**
```kotlin
val items = listOf(1, -2 ,-3 , 4, 5, 0, 2, -2)
```
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>