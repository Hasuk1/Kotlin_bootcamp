# **ВОПРОСЫ С СОБЕСЕДОВАНИЙ ПО ANDROID**

## **Содержание**

1. [Базовые вопросы](#базовые-вопросы)

2. Алгоритмы, структуры данных, хранение данных

3. Работа с сетью

4. Многопоточность, Java Core, RxJava

5. Android SDK, Kotlin

6. Другое

7. Практические задачи


## **Базовые вопросы** 

#### [Содержание<---](#содержание)

### 1. **Назовите основные принципы ООП.**

- ***Наследование*** - создание новых сущностей(шаблонов) на основе уже существующих. 
- ***Полиморфизм*** - возможность иметь разные формы для одной и той же сущности. Он делится на статический (мнимый) и динамический (истинный). Суть разделения заключается в том, что разные виды происходят в разные этапы выполенения программы. Статический (мнимый) - происходит на этапе компиляции, из примеров могу назвать приведение типов, но это не применимо к строго типизированный языкам, к которым относиться Kotlin и Java. Динамический (истинный) - происходит во рвемя выполенния кода. Как вариант это несколько методов с разными входными аргументами. 
    - ***3 типа полиморфизма в Kotlin:***
        - Ad hoc (по случаю) – одна функция определяется для различных типов    данных. В классе прописывается несколько функций, которые принимают    разные параметры. При вызове этой функции, компилятор определяет какая     функция сработает по количеству и типам передаваемых параметров. Минус  такого подхода, в том, что нужно наделать множество реализаций этой  функции.
        - Subtyping (полиморфизм включения) – это реализация через принцип  подстановки Барбары Лисков. Это один из принципов    объектно-ориентированного программирования из аббревиатуры SOLID.  Почитайте об этом. А звучит он так: функции, которые используют базовый  тип, должны иметь возможность использовать подтипы базового типа, не     зная об этом. То есть объект более узкого типа всегда может     использоваться там, где может использоваться объект более широкого  типа. Здесь, кстати и может сбить с толку факт отношений наследования    родителя и потомка, о чем я упоминал вначале.
        - Parametric (параметрический) – программа может быть реализована через     обобщенные типы. То есть без ориентации на конкретный тип. Касаемо  Kotlin – это история про дженерики (или обобщенное программирование). О  них поговорим в другой раз.

- ***Инкапсуляци*** - сокрытие реализации.
- ***Абстракция*** - набор общих характеристик.
- ***Посылка сообщений*** - форма связи, взаимодействия между сущностями.
- ***Переиспользование*** - все что перечислено выше работает на повторное использование кода.


### 2. **Что такое класс? Что такое интерфейс? Какая между ними разница?**

- ***Класс*** - это способ описания сущности. Его шаблон, который имеет минимальный набор общих характеристик для работы с ним. Классы являются ссылочным типом данных, тоесть в куче(heap) будет храниться только ссылка на данные из стэка. 
    - ***Объект*** - это экземпляр класса, который имеет все теже поля и методы, но значения в разных объектха могут различаться. 
- ***Интерфейс*** изначально это шаблон проектирования. В Kotlin - это некое соглашение для класса, который будет использовать (наследоваться) интерфейс, которое обязывает последнего реализовать заключенный с интерфейсом контракт(методы/поля). 

    ```kotlin
    interface Movable{
        var speed: Int  // объявление свойства
        fun move()      // определение функции без реализации
        fun stop(){     // определение функции с реализацией по умолчанию
            println("Остановка")
        }
    }

    class Car : Movable{
        // обязательно реализовать(override) только то,
        // что в interface не имеет реализации по умолчанию
        override var speed = 60
        override fun move(){
            println("Машина едет со скоростью $speed км/ч")
        }
    }
    ```
- ***Отличия***:
    - ***interface*** под оберткой представляет из себя abstract class, который запрещает создавать объекты этого класса.
    - ***class*** в kotlin изначально *final*, наследоваться можно только от *open* классов, при этом наследование может быть только одинарное, ***interface*** в свою очередь поддерживает множественное наследование. 


### **3. Назовите базовые типы данных.**

- В Kotlin все типы это классы. Any - топ класс, от которого наследуются другие классы, также есть подтип всех типов - Nothing(ничего).
- Все примитвные типы разделены на нулабельные и нет, дополнительно можно выделить платформ тайп, используется для обратной совместимости, когда не известено объект нулабельный или нет. 
- Функциональные типы Unit
- Коллекции, которые дополнительно разделены на изменяемые и нет.

### **4. В чем отличие примитивных типов от объектов?**
- Кроме описанного ранее поясния, что такое [класс](#2-что-такое-класс-что-такое-интерфейс-какая-между-ними-разница), также можно отметить, что объект будет иметь еще методы, которые будут выполнять какие либо действия.

### **5. Какая разница между абстрактным классом и интерфейсом?**
- Абстрактный класс - это заготовка для классов, которые имеют общую сущность, а интерфейса - это контракт, который обязывает другой объект реализовать некоторые свойства/методы.
- Также абстрактный класс может иметь стандратное значение для поля, тоесть хранить какие-либо данные. Интерфейс же может иметь только стандартную реализацию методов.

### **6. Что такое паттерны проектирования? Какие паттерны вы знаете?**
- Паттерн — это типовое решение для часто встречающейся задачи при создании программ. Они испльзуются для проектирования и структуризации программы.
    - Фасад (Facade) - абстрагирует работу с несколькими классами, объединяя их единым интерфейсом взаимодействия.
    - Стратегия (Strategy) - используется для семейства схожих алгоритмов. Позволяет выбирать алгоритм путём определения соответствующего класса.
    - Прокси/Заместитель (Proxy) -  является посредником между двумя другими объектами, и который реализует/ограничивает доступ к объекту, к которому обращаются через него.
    - Шаблонный метод (Template method)	- определяет основу алгоритма и позволяет наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом.
    - Шаблон делегирования (Delegation pattern) - выражает некоторое поведение, но в реальности передаёт ответственность за выполнение этого поведения связанному объекту. ***Поддерживается Kotlin нативно, через "Делегированные свойства"***
    - Одиночка (Singleton) - такой класс, может иметь только один экземпляр. Конструктор приватный, можно получить ссылку на объект через соответствующий метод.

### **7. Чем отличается Java от Kotlin?**

>>>

- Меньше кода = быстрее разработка.
- Null Safety для исклчения NullPointerExcpetion из Java.
- Расширение класса без наследования.
- Data-класс, для хранения данных, компилятор сгенерирует методы HashCode(), toString(), equal()/==.

<<<

## **Алгоритмы**

#### [Содержание<---](#содержание)

### **8. Что такое алгоритм и как выбрать правильный?**

9. Что такое сложность алгоритма? Как и с помощью чего её можно вычислить?

10. Что такое нотация big-O?

11. Что такое рекурсия?

12. Какие алгоритмы сортировки вы знаете?

 

Структуры данных

13. Расскажите о таких структурах данных, как List, Set, Map?

14. Какая разница между ArrayList и LinkedList?

 

Ответы на эти вопросы вы найдёте в вебинаре Структуры данных в Java и Kotlin.

 

Хранение данных

15. Как можно хранить данные в Android?

16. Когда следует использовать SharedPreferences?

17. Из каких компонентов состоит библиотека Room?

18. Что такое @PrimaryKey, @Ignore, @Embedded, @TypeConverters в Room?

19. Для чего нужна миграция в базах данных?

 

Ответы на некоторые из этих вопросов вы найдете в видео курсе SQLite. Базы данных в Android приложениях (урок 2, урок 3).

 

Работа с сетью

20. Что такое JSON, XML?

21. Какие варианты реализации работы с сервером?

22. Что такое REST?

 

Ответы на некоторые из этих вопросов вы найдете в видео курсах Разработка приложений под Android. Базовый курс (урок 2), Android Углубленный (урок 9).

 

Многопоточность

23. Что такое процесс?

24. Что такое поток?

25. Для чего используют ключевое слово synchronized?

26. Зачем синхронизировать потоки?

27. Какая разница между синхронным и асинхронным исполнением?

28. Как мы можем создать поток в Java?

29. Что такое deadlock?

30. Какие варианты реализации многопоточности есть в Android?

31. Что такое main thread? Какие операции нужно выполнять на main thread, а какие нельзя делать?

 

Ответы на некоторые из этих вопросов вы найдете в видео курсе Android Углубленный (урок 5).

 

Java Core

32. Что такое Exceptions? Зачем они нужны?

33. Зачем используют ключевые слова final, finally и finalize?

34. Что такое абстрактный класс? Что такое интерфейс?

35. Что такое анонимный класс? Использовали ли на практике? Для чего?

36. Что такое статический класс (static class)?

37. Что такое enum? Зачем его используют?

38. Можем ли мы сделать конструктор приватным?

39. Какая разница между ключевыми словами throw и throws?

40. Какая разница между Error и Exception?

41. Какая разница между checked и unchecked exception?

42. Что такое Object class и какие методы он имеет?

43. Какие существуют модификаторы доступа для классов? Какая разница между ними?

44. Что такое итератор?

45. Как безопасно удалить элемент из коллекции?

46. Зачем нам переопределять equals() и когда не нужно это делать?

47. Какой должен выполняться контракт при переопределении equals()?

 

Ответы на некоторые из этих вопросов вы найдете в вебинаре Что такое Java EE и Java Core и видео курсе Java Базовый (урок 2, урок 4, урок 6, урок 7, урок 8, урок 9).

 

RxJava

48. В чем разница между map() и flatMap() в RxJava?

49. Когда используете observeOn(), а когда subscribeOn()?

50. Как можно обработать ошибки в RxJava?

51. Какие schedulers знаете в RxJava? Назовите их отличия.

52. Что такое Disposable? Зачем его используют?

53. В чем разница между Hot и Cold Observables? Назовите примеры в RxJava.

 

Ответы на некоторые из этих вопросов вы найдете в видео курсе Создание пользовательских элементов управления в Android (урок 1).

 

Android SDK

54. Какие базовые Android-компоненты можете назвать?

55. Что такое ContentProvider?

56. Какие типы Service знаете?

57. Что такое BroadcastReceiver и какие типы существуют?

58. Для чего используют механизм фрагментов?

59. Опишите жизненный цикл Activity.

60. Опишите жизненный цикл Fragment.

61. Есть ли у Fragment контекст? Если да, то как его получить?

62. Чем отличается Fragment от Activity? Зачем выдумали Fragment?

63. Что такое изменение конфигурации? Что происходит с приложением на Android при этом?

64. Что такое Intent? Что такое explicit/implicit Intent?

Тема связана со специальностями:

 
Java Developer
 
Android Developer
 
С чего начать?
65. Что такое SharedPreferences?

66. Что такое ANR? Как избегать таких ситуаций?

67. Что такое DataBinding?

68. Что такое LiveData? Какие виды знаете?

69. Как создать ViewModel? Почему создавать ViewModel нужно именно так?

70. Что такое Context и зачем он?

71. Что такое AndroidManifest.xml? Зачем его используют? Что мы можем там декларировать?

72. Перечислите layout, с которыми работали? Когда и какой нужно использовать?

73. Расскажите, что нужно реализовать, чтобы отобразить список строк в RecyclerView.

74. Объясните паттерн ViewHolder. Для чего он применяется?

75. Что такое DiffUtil?

76. Расскажите о ConstraintLayout.

77. Для чего используют Group, Guideline, Barriers, Chains в ConstraintLayout?

78. У вас есть Activity с двумя Fragment'ами, у одного есть кнопка, у другого TextView. При нажатии кнопки изменяется TextView. Как вы реализуете это?

79. Что такое WorkManager? Когда используем?

 

Ответы на некоторые из этих вопросов вы найдете в видео курсах Разработка приложений под Android. Базовый курс (урок 2, урок 4, урок 5, урок 7), Android Углубленный (урок 3, урок 6, урок 9), Android User Interface (урок 3), Создание пользовательских элементов управления в Android (урок 9).

 

Kotlin

80. Как вы понимаете термин Null safety?

81. Что такое nullable и non-nullable типы? Какая разница между val и var?

82. Как задекларировать getter/setter для property?

83. Почему классы Kotlin по умолчанию final?

84. Что такое sealed class?

85. Что такое data classes?

86. Какая разница между sealed class и enum?

87. Почему у Kotlin нет checked exceptions?

88. Что такое Extensions? Использовали ли вы их на практике?

89. Что такое перегрузка операторов (operator overloading)? Зачем нужен этот механизм?

90. Как работают примитивы в Kotlin?

91. Расскажите об объекте Unit в Kotlin.

92. Расскажите об объекте Any в Kotlin.

93. Как создать Singleton объект в Kotlin?

94. Что такое companion object?

95. Чем отличается const val от val?

96. Какие знаете модификаторы доступа?

97. Что означает модификатор lateinit?

98. Coroutines – что это за механизм? Использовали ли его на практике?

99. Зачем нужны Coroutines? Чем они лучше обычных тредов?

100. Что такое suspend-функция?

101. Что такое Job?

102. Что такое Dispatcher? Какие есть виды?

102. Что такое Scope?

103. Как писать Java compatible API в Kotlin?

 

Ответы на некоторые из этих вопросов вы найдете в видео курсе Kotlin.

 

Другое

104. Расскажите, что такое memory leak. Как избежать?

105. Как бы вы искали memory leak?

106. Расскажите о Dependency injection. Какие варианты реализации в Android?

107. Для чего нужна система контроля версий?

108. Что такое Git?

109. Для чего используем .gitignore-файл?

110. Расскажите о командах push, pull, fetch в Git?

111. Что такое merge и rebase? Какая разница?

112. Что такое CI? Зачем используем?

 

Ответы на некоторые из этих вопросов вы найдете в видео курсах Dependency Injection в Android-разработке, Основы работы с Git.

 

Практические задачи

113. Разверните Linked List. Отпишите о зацикленности в LinkedList или ее отсутствии.

114. Напишите функцию, которая вернет n первых неотъемлемых чисел:

un nMin(items: List<String>, n: Int): List<Int> {
//return n minimal non negative items
}

Пример вызова функции: nMin(listOf("1","-11","-12","22","100","-30",”2”, “5”), 3)

Ожидаемый результат: [1, 22, 100]

115. Что будет выведено в консоль? Объясните результат.

var globalId = 0
data class User(val name: String) {
val id = globalId++
}
fun main(args: Array<String>) {
val user1 = User("User")
val user2 = User("User")
println(user1)
println(user2)
println(user1 == user2)
}

116. Исправьте все ошибки в коде:

class Animal
class Dog: Animal {}

117. Для коллекции items:

val items = listOf(1, -2 ,-3 , 4, 5, 0, 2, -2)

Подсчитайте количество отрицательных элементов.
Вычислите среднее арифметическое значение отрицательных и неотрицательных чисел.