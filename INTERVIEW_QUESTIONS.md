# **ВОПРОСЫ С СОБЕСЕДОВАНИЙ ПО ANDROID**

## **Содержание**

1. [Базовые вопросы](#базовые-вопросы)

    1.1 [Что такое SOLID?](#1-что-такое-solid)

    1.2 [Назовите основные принципы ооп.](#2-назовите-основные-принципы-ооп)

    1.3 [Что такое класс? Что такое интерфейс? Какая между ними разница?](#3-что-такое-класс-что-такое-интерфейс-какая-между-ними-разница)

    1.4 [Назовите базовые типы данных.](#4-назовите-базовые-типы-данных)

    1.5 [В чем отличие примитивных типов от объектов?](#5-в-чем-отличие-примитивных-типов-от-объектов)

    1.6 [Какая разница между абстрактным классом и интерфейсом?](#6-какая-разница-между-абстрактным-классом-и-интерфейсом)

    1.7 [Что такое паттерны проектирования? Какие паттерны вы знаете?](#7-что-такое-паттерны-проектирования-какие-паттерны-вы-знаете)

    1.8 [Чем отличается Java от Kotlin?](#8-чем-отличается-java-от-kotlin)

2. [Алгоритмы](#алгоритмы)

    2.1 [Что такое алгоритм и как выбрать правильный?](#1-что-такое-алгоритм-и-как-выбрать-правильный)

    2.2 [Что такое сложность алгоритма? Как и с помощью чего её можно вычислить?](#2-что-такое-сложность-алгоритма-как-и-с-помощью-чего-её-можно-вычислить)

    2.3 [Что такое нотация big-O?](#3-что-такое-нотация-big-o)

    2.4 [Что такое рекурсия?](#4-что-такое-рекурсия)

    2.5 [Какие алгоритмы сортировки вы знаете?](#5-какие-алгоритмы-сортировки-вы-знаете)

3. [Структуры данных](#структуры-данных)

    3.1 [Расскажите о таких структурах данных, как List, Set, Map?](#1-расскажите-о-таких-структурах-данных-как-list-set-map)

    3.2 [Какая разница между ArrayList и LinkedList?](#2-какая-разница-между-arraylist-и-linkedlist)

4. [Хранение данных](#хранение-данных)

    4.1 [Как можно хранить данные в Android?](#1-как-можно-хранить-данные-в-android)

    4.2 [Когда следует использовать SharedPreferences?](#2-когда-следует-использовать-sharedpreferences)

    4.3 [Из каких компонентов состоит библиотека Room?](#3-из-каких-компонентов-состоит-библиотека-room)

    4.4 [Что такое @PrimaryKey, @Ignore, @Embedded, @TypeConverters в Room?](#4-что-такое-primarykey-ignore-embedded-typeconverters-в-room)

    4.5 [Для чего нужна миграция в базах данных?](#5-для-чего-нужна-миграция-в-базах-данных)

5. [Работа с сетью](#работа-с-сетью)

    5.1 [Что такое JSON, XML?](#1-что-такое-json-xml)

    5.2 [Какие варианты реализации работы с сервером?](#2-какие-варианты-реализации-работы-с-сервером)

    5.3 [Что такое REST?](#3-что-такое-rest)

6. [Многопоточность](#многопоточность)

    6.1 [Что такое процесс?](#1-что-такое-процесс)

    6.2 [Что такое поток?](#2-что-такое-поток)

    6.3 [Для чего используют ключевое слово synchronized?](#3-для-чего-используют-ключевое-слово-synchronized)

    6.4 [Зачем синхронизировать потоки?](#4-зачем-синхронизировать-потоки)

    6.5 [Какая разница между синхронным и асинхронным исполнением?](#5-какая-разница-между-синхронным-и-асинхронным-исполнением)

    6.6 [Как мы можем создать поток в Java?](#6-как-мы-можем-создать-поток-в-java)

    6.7 [Как мы можем создать поток в Kotlin?](#7-как-мы-можем-создать-поток-в-kotlin)

    6.8 [Что такое deadlock?](#7-что-такое-deadlock)

    6.9 [Какие варианты реализации многопоточности есть в Android?](#8-какие-варианты-реализации-многопоточности-есть-в-android)

    6.10 [Что такое main thread? Какие операции нужно выполнять на main thread, а какие нельзя делать?](#9-что-такое-main-thread-какие-операции-нужно-выполнять-на-main-thread-а-какие-нельзя-делать)

7. [Java Core](#java-core)

    7.1 [Зачем используют ключевые слова final, finally и finalize?](#1-зачем-используют-ключевые-слова-final-finally-и-finalize)

8. [RxJava](#rxjava)

9. [Android SDK](#android-sdk)

    9.1 [Какие базовые Android-компоненты можете назвать?](#1-какие-базовые-android-компоненты-можете-назвать)

    9.2 [Для чего используют механизм фрагментов?](#2-для-чего-используют-механизм-фрагментов)
    
    9.3 [Опишите жизненный цикл Activity.](#3-опишите-жизненный-цикл-activity)
    
    9.4 [Опишите жизненный цикл Fragment.](#4-опишите-жизненный-цикл-fragment)
    
    9.5 [Есть ли у Fragment контекст? Если да, то как его получить?](#5-есть-ли-у-fragment-контекст-если-да-то-как-его-получить)
    
    9.6 [Что такое изменение конфигурации? Что происходит с приложением на Android при этом?](#6-что-такое-изменение-конфигурации-что-происходит-с-приложением-на-android-при-этом)
    
    9.7 [Что такое Intent? Что такое explicit/implicit Intent?](#7-что-такое-intent-что-такое-explicitimplicit-intent)
    
    9.8 [Что такое SharedPreferences?](#8-что-такое-sharedpreferences)
    
    9.9 [Что такое ANR? Как избегать таких ситуаций?](#9-что-такое-anr-как-избегать-таких-ситуаций)
    
    9.10 [Что такое DataBinding?](#10-что-такое-databinding)
    
    9.11 [Что такое LiveData? Какие виды знаете?](#11-что-такое-livedata-какие-виды-знаете)
    
    9.12 [Как создать ViewModel? Почему создавать ViewModel нужно именно так?](#12-как-создать-viewmodel-почему-создавать-viewmodel-нужно-именно-так)    
    
    9.13 [Что такое Context и зачем он?](#13-что-такое-context-и-зачем-он)    
    
    9.14 [Что такое AndroidManifest.xml? Зачем его используют? Что мы можем там декларировать?](#14-что-такое-androidmanifestxml-зачем-его-используют-что-мы-можем-там-декларировать)    
    
10. [Kotlin](#kotlin)

    10.1 [Как вы понимаете термин Null-safety](#1-как-вы-понимаете-термин-null-safety)
    
    10.2 [Что такое nullable и non-nullable типы? Какая разница между val и var?](#2-что-такое-nullable-и-non-nullable-типы-какая-разница-между-val-и-var)
    
    10.3 [Как задекларировать getter/setter для property?](#3-как-задекларировать-gettersetter-для-property)
    
    10.2 [Почему классы Kotlin по умолчанию final?](#2-почему-классы-kotlin-по-умолчанию-final)
        
    10.3 [Как работают примитивы в Kotlin?](#3-как-работают-примитивы-в-kotlin)
    
    10.4 [Расскажите об объекте Unit в Kotlin.](#4-расскажите-об-объекте-unit-в-kotlin)
        
    10.5 [Как создать Singleton объект в Kotlin?](#5-как-создать-singleton-объект-в-kotlin)
    
    10.6 [Что такое companion object?](#6-что-такое-companion-object)
    
    10.7 [Чем отличается const val от val?](#7-чем-отличается-const-val-от-val)
    
    10.8 [Какие знаете модификаторы доступа?](#8-какие-знаете-модификаторы-доступа)
        
    10.9 [Что такое suspend-функция?](#9-что-такое-suspend-функция)
    
    10.10 [Что такое Job?](#10-что-такое-job)
    
    10.11 [Что такое Dispatcher? Какие есть виды?](#11-что-такое-dispatcher-какие-есть-виды)
    
    10.12 [Что такое Scope?](#12-что-такое-scope)
    
11. [Другое](#другое)

12. [Практические задачи](#практические-задачи)


## **Базовые вопросы** 

#### [Содержание<---](#содержание)

### **1. Что такое [SOLID](https://javarush.com/groups/posts/3650-principih-solid-kotorihe-sdelajut-kod-chijshe)?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>S</b>ingle Responsibility Principle (Принцип единственной ответственности)</LI>
        <LI><b>O</b>pen-Closed Principle (Принцип открытости-закрытости)</LI>
        <LI><b>L</b>iskov Substitution Principle (Принцип подстановки Барбары Лисков)</LI>
        <LI><b>I</b>nterface Segregation Principle (Принцип разделения интерфейса)</LI>
        <LI><b>D</b>ependency Inversion Principle (Принцип инверсии зависимостей)</LI>
    </UL>
</details>

### **2. Назовите основные принципы ООП.**

<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Наследование</b> - создание новых сущностей(шаблонов) на основе уже существующих.</LI>
        <LI><b>Полиморфизм</b> - возможность иметь разные формы для одной и той же сущности. Он     делится на статический (мнимый) и динамический (истинный). Суть разделения  заключается в том, что разные виды происходят в разные этапы выполенения программы.  Статический (мнимый) - происходит на этапе компиляции, из примеров могу назвать  приведение типов, но это не применимо к строго типизированный языкам, к которым  относиться Kotlin и Java. Динамический (истинный) - происходит во рвемя выполенния   кода. Как вариант это несколько методов с разными входными аргументами.</LI>
        <UL>
            <LI><b>3 типа полиморфизма в Kotlin:</b></LI>
            <UL>
                <LI><b>Ad hoc (по случаю)</b> – одна функция определяется для различных типов данных. В классе прописывается несколько функций, которые принимают разные параметры. При вызове этой функции, компилятор определяет какая функция сработает по количеству и типам передаваемых параметров. Минус такого подхода, в том, что нужно наделать множество реализаций этой функции.</LI>
                <LI><b>Subtyping (полиморфизм включения)</b> – это реализация через принцип подстановки Барбары Лисков. Это один из принципов объектно-ориентированного программирования из аббревиатуры SOLID. Почитайте об этом. А звучит он так: функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом. То есть объект более узкого типа всегда может использоваться там, где может использоваться объект более широкого типа. Здесь, кстати и может сбить с толку факт отношений наследования родителя и потомка, о чем я упоминал вначале.</LI>
                <LI><b>Parametric (параметрический)</b> – программа может быть реализована через обобщенные типы. То есть без ориентации на конкретный тип. Касаемо Kotlin – это история про дженерики (или обобщенное программирование). О них поговорим в другой раз.</LI>
            </UL>
        </UL>
        <LI><b>Инкапсуляци</b> - сокрытие реализации.</LI>
        <LI><b>Абстракция</b> - набор общих характеристик.</LI>
        <LI><b>Посылка сообщений</b> - форма связи, взаимодействия между сущностями.</LI>
        <LI><b>Переиспользование</b> - все что перечислено выше работает на повторное использование кода.</LI>
    </UL>
</details>

### **3. Что такое класс? Что такое интерфейс? Какая между ними разница?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Класс</b> - это способ описания сущности. Его шаблон, который имеет минимальный набор общих характеристик для работы с ним. Классы являются ссылочным типом данных, тоесть в куче(heap) будет храниться только ссылка на данные из стэка. </LI>
        <UL>
            <LI><b>Объект</b> - это экземпляр класса, который имеет все теже поля и методы, но значения в разных объектха могут различаться. </LI>
        </UL>
        <LI><b>Интерфейс</b> изначально это шаблон проектирования. В Kotlin - это некое соглашение для класса, который будет использовать (наследоваться) интерфейс, которое обязывает последнего реализовать заключенный с интерфейсом контракт(методы/поля).
<pre><code><span style="color:orange;">interface</span> Movable{
    <span style="color:orange;">var</span> <span style="color:MediumOrchid;">speed</span>: Int  <span style="color:gray;">// объявление свойства</span>
    <span style="color:orange;">fun</span> move</span>()      // определение функции без реализации</span>
    <span style="color:orange;">fun</span> stop(){     // определение функции с реализацией по умолчанию</span>
        println("Остановка"</span>)
    }
}
<span style="color:orange;">class</span> Car : Movable{
    <span style="color:gray;">// обязательно реализовать(override) только то,
    <span style="color:gray;">// что в interface не имеет реализации по умолчанию</span>
    <span style="color:orange;">override var</span> <span style="color:MediumOrchid;">speed</span> = 60</span>
    <span style="color:orange;">override fun</span> <span style="color:DodgerBlue;">move</span>(){
        println(<span style="color:green;">"Машина едет со скоростью $speed км/ч"</span>)
    }
}</pre></code>        
        </LI>
        <LI><b>Отличия</b>
        <UL>
            <LI><b>interface</b> под оберткой представляет из себя <code>abstract class</code>, который запрещает создавать объекты этого класса.</LI>
            <LI><b>class</b> в kotlin изначально <code>final</code>, наследоваться можно только от <code>open</code> классов, при этом наследование может быть только одинарное, <code>interface</code> в свою очередь поддерживает множественное наследование. </LI>
        </UL>
        </LI>
    </UL>
</details>

### **4. Назовите базовые типы данных.**

<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>В Kotlin все типы это классы. Any - топ класс, от которого наследуются другие классы, также есть подтип всех типов - Nothing(ничего).</LI>
        <LI>Все примитвные типы разделены на нулабельные и нет, дополнительно можно выделить платформ тайп, используется для обратной совместимости, когда не известено объект нулабельный или нет. </LI>
        <LI>Функциональные типы.</LI>
        <UL>
        <LI><b>Функции высшего порядка (Higher-Order Functions)</b>: Это функции, которые принимают другие функции в качестве параметров или возвращают функции в качестве результатов. Например:<br>
<pre><code><span style="color:orange;">fun</span> <span style="color:DodgerBlue;">operateOnNumbers</span>(
  a: Int, b: Int,
  operation: (Int, Int) -> Int
): Int {
  <span style="color:orange;">return</span> operation(a, b)
}</pre></code>
        </LI>
        <LI><b>Типы функций (Function Types)</b>: Это типы данных, которые представляют собой сигнатуры функций. В Kotlin функциональные типы обычно записываются в следующем формате: (parameters) -> return_type. Например:<br>
<pre><code><span style="color:orange;">val</span> <span style="color:DodgerBlue;">add</span>: (Int, Int) -> Int = { a, b -> a + b }</pre></code>
        </LI>
        </UL>
        <LI>Коллекции, которые дополнительно разделены на изменяемые и нет.</LI>
    </UL>
</details>

### **5. В чем отличие примитивных типов от объектов?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>Кроме описанного ранее поясния, что такое <a href='#2-что-такое-класс-что-такое-интерфейс-какая-между-ними-разница'>класс</a>, также можно отметить, что объект будет иметь еще методы, которые будут выполнять какие либо действия.</LI>
    </UL>
</details>

### **6. Какая разница между абстрактным классом и интерфейсом?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Абстрактный класс</b> - это заготовка для классов, которые имеют общую сущность, а интерфейса - это контракт, который обязывает другой объект реализовать некоторые свойства/методы.</LI>
        <LI>Также абстрактный класс может иметь стандратное значение для поля, тоесть хранить какие-либо данные. Интерфейс же может иметь только стандартную реализацию методов.</LI>
    </UL>
</details>

### **7. Что такое паттерны проектирования? Какие паттерны вы знаете?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Паттерн</b> — это типовое решение для часто встречающейся задачи при создании программ. Они испльзуются для проектирования и структуризации программы.</LI>
        <UL>
            <LI><b>Фасад (Facade)</b> - абстрагирует работу с несколькими классами, объединяя их единым интерфейсом взаимодействия.</LI>
            <LI><b>Стратегия (Strategy)</b> - используется для семейства схожих алгоритмов. Позволяет выбирать алгоритм путём определения соответствующего класса.</LI>
            <LI><b>Прокси/Заместитель (Proxy)</b> -  является посредником между двумя другими объектами, и который реализует/ограничивает доступ к объекту, к которому обращаются через него.</LI>
            <LI><b>Шаблонный метод (Template method)</b> - определяет основу алгоритма и позволяет наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом.</LI>
            <LI><b>Шаблон делегирования (Delegation pattern)</b> - выражает некоторое поведение, но в реальности передаёт ответственность за выполнение этого поведения связанному объекту. <i>Поддерживается Kotlin нативно, через "Делегированные свойства"</i></LI>
            <LI><b>Одиночка (Singleton)</b> - такой класс, может иметь только один экземпляр. Конструктор приватный, можно получить ссылку на объект через соответствующий метод.</LI>
        </UL>
    </UL>
</details>

### **8. Чем отличается Java от Kotlin?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>Меньше кода = быстрее разработка.</LI>
        <LI>Null Safety для исключений NullPointerExcpetion из Java.</LI>
        <LI>Расширение класса без наследования.</LI>
        <LI>Data-класс, для хранения данных, компилятор сгенерирует методы HashCode(), toString(), equal()/==.</LI>
    </UL>
</details>

## **Алгоритмы**

#### [Содержание<---](#содержание)

### **1. Что такое алгоритм и как выбрать правильный?**

### **2. Что такое сложность алгоритма? Как и с помощью чего её можно вычислить?**

### **3. Что такое нотация big-O?**

### **4. Что такое рекурсия?**

### **5. Какие алгоритмы сортировки вы знаете?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Быстрая</b></LI>
        <LI><b>Слиянием</b></LI>
        <LI><b>Пузырькем</b></LI>
        <LI><b>Поразрядная</b></LI>
    </UL>
</details>

## **Структуры данных**

#### [Содержание<---](#содержание)

### **1. Расскажите о таких структурах данных, как List, Set, Map?**

### **2. Какая разница между ArrayList и LinkedList?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>Аналогично с Array и List.</LI>
    </UL>
</details>

## **Хранение данных**

#### [Содержание<---](#содержание)

### **1. Как можно хранить данные в Android?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>SharedPreference</b> - хранение небольших объемов данных в виде пар ключ-значение. Отлично подходит для хранения настроек приложения.</LI>
        <LI><b>Файлы.</b></LI>
        <LI><b>SQLite</b> - легковесная реляционная база данных, встроенная в Android.Используется для хранения структурированных данных, таких как списки контактов, журналы и другие.</LI>
        <LI>Внешние службы хранения данных (Firebase Realtime Database, ...).</LI>
        <LI>DataStore (Part of Android Jetpack)</LI>
    </UL>
</details>

### **2. Когда следует использовать SharedPreferences?**

### **3. Из каких компонентов состоит библиотека [Room](https://developer.android.com/jetpack/androidx/releases/room)?**

### **4. Что такое @PrimaryKey, @Ignore, @Embedded, @TypeConverters в Room?**

### **5. Для чего нужна миграция в базах данных?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>- Применятся для переноса данных из текущей БД в новую без потери данных.</LI>
    </UL>
</details>

## **Работа с сетью**

#### [Содержание<---](#содержание)

### **1. Что такое JSON, XML?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>JSON</b> – это текстовый формат обмена данными, основанный на языке JavaScript. Используется для хранения примитивных типов данных.</LI>
        <LI><b>XML</b> – это расширяемый язык разметки. Поддерживает более сложные типы данных (изображения, даты, ...)</LI>
    </UL>
</details>

### **2. Какие варианты реализации работы с сервером?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>HTTP-запросы (GET, POST, PUT, ...)</LI>
        <LI>WebSocket</LI>
        <LI>RESTful API</LI>
    </UL>
</details>

### **3. Что такое REST?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>REST (Representational State Transfer)</b> - это архитектурный стиль, используемый для создания веб-сервисов. Он определяет набор правил и ограничений для создания API, которые позволяют клиентам выполнять операции CRUD (Create, Read, Update, Delete) с ресурсами на сервере.
Система разделена на клиентов и серверы, которые независимо развиваются и могут изменяться без влияния на другую сторону. Все ресурсы в системе должны быть доступны через унифицированный интерфейс, который включает в себя стандартные методы HTTP (GET, POST, PUT, DELETE) и правильное использование HTTP статусных кодов.</LI>
    </UL>
</details>

## **Многопоточность**

#### [Содержание<---](#содержание)

### **1. Что такое процесс?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Процесс</b> - экземпляр исполняемой программы, под который были выделени ресурсы системы. Процесс ограничен адресным просранством и изначально не имеет доступ к переменным или структурам другого процесса.</LI>
    </UL>
</details>

### **2. Что такое поток?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Поток</b> - способ исполнения процесса, он находится в том же пространстве, что и процесс, но имеет доступ к другим потокам. Если поток изменил ресурс процесса, эти изменения видны для других потоков, дополнительно могу отметить, что каждый поток имеет свой стэк в рамках процесса, но также имеет доступ к стэкам и других потоков.</LI>
    </UL>
</details>

### **3. Для чего используют ключевое слово synchronized?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>Т.к. потоки работают независимо друг от друга, то может возникнуть ситуация, когда ресурс изменяется сразу несколькими потоками, к примеру вывод в консоль. I поток вывет свой код, а II поток выведет свой, в итоге они сольются.<br>
        Чтобы такая ситуация не возникала используются Mutex'ы.
        <UL>
            <LI><b>Mutex</b> ограничивает доступ к объекту в опредленное время для других потоков, если его уже взял какой-либо поток. Доступ будет открыт только после того, как взявший его поток закончит работу.</LI>
            <LI><b>Ключевое слово synchronized</b> используется для пометки метода или объекта. Если один поток зашел внутрь блока кода, который помечен словом synchronized, он моментально захватывает мьютекс объекта, и все другие потоки, которые попытаются зайти в этот же блок или метод вынуждены ждать, пока предыдущий поток не завершит свою работу и не освободит mutex.</LI>
        </UL>
        </LI>
    </UL>
</details>

### **4. Зачем синхронизировать потоки?**

### **5. Какая разница между синхронным и асинхронным исполнением?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Синхронное исполнение</b></LI>
        <UL>
            <LI>Задачи исполняются последовательно, одна за другой.<br>Порядок исполнения = порядку вызова.</LI>
            <LI>Исполняемая в момент задача блокирует выполнение следующей, соответственно вызываемый поток будет ожидать завершения задачи.</LI>
        </UL>
        <LI><b>Асинхронное исполнение</b></LI>
        <UL>
            <LI>Задачи выполняются разрознено без ожидания завершения других задач.</LI>
            <LI>Используется для выполнения длительных задач в фоне, без остановки основного потока(приложения).</LI>
        </UL>
    </UL>
</details>


### **6. Как мы можем создать поток в Java?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>От класса Thread можно наследоваться и описать исполнения какого-либо процесса в блоке метода <b><i>run()</b></i></LI>
    </UL>
</details>

### **7. Как мы можем создать поток в Kotlin?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Использование корутин (Coroutines)</b><br><b>Coroutines</b> - это легковесные потоки, которые не блокируют основной поток выполнения.</LI>
        <UL>
            <LI>Для испльзования корутин, нужно определить <b>область корутин</b>.
            <UL>
                <LI><b>GlobalScope</b> - глобальная область, которая доступна на протяжении всего жизненного цикла приложения. Соответственно является областью всего kotlin приложения.</LI>
                <LI><b>CoroutineScope</b> - локальная область, доступна только в рамках какого-либо компонента приложения.</LI>
                <UL>
                    <LI><b>ViewModelScope</b> - область, предназначенная для использования в архитектуре приложений, основанных на  архитектурном компоненте ViewModel из Android Jetpack. Эта область корутины автоматически отменяется при уничтожении ViewModel</LI>
                </UL>
                <LI><i>Чтобы в указанной области запустить корутину, функция должна быть помечана как <code>suspend</code></i><br>При определении (<code>fun getUsers(): Flow&lt;String&rt;</code>) функции-потока (в данном случае функции getUsers) необязательно использовать модификатор suspend.</LI>
            </UL>
        </UL>
        <LI><b>Использование асинхронных потоков (Flow)</b><br><b>Flow</b> - это интерфейс, для создания подобных потоков. По сути асинхронный поток - это объект Flow. Он типизируется (Flow < String > ) типом тех данных, которые должны передаваться в потоке.<br>Для создания объекта Flow применяется специальная функция <code><br>fun getUsers(): Flow<String> = flow {<br>&nbsp// создание асинхронного потока в функции flow<br>&nbspemit(item) // передаем значение в поток<br>}</code><br>Во внешнем коде в функции main вызываем функцию-поток getUsers(). Для управления объектами из потока для интерфейса Flow определен ряд функций, одной из которых является функция collect(). В качестве параметра она принимает функцию, в которую передает эмитируемый объект из потока. Так, в данном случае это просто функция вывода на консоль:<br><code>getUsers().collect { user -> println(user) }</code></LI>
    </UL>
</details>

### **8. Что такое deadlock?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>deadlock</b> - ситуация, когда потоки блокируются, что происхоит, к примеру, в следствии ситуации:
        <OL>
          <LI>Поток A захватывает ресурс X</LI>
          <LI>Поток B захватывает ресурс Y.</LI>
          <LI>Поток A пытается захватить ресурс Y, но он уже захвачен потоком B и ожидает его освобождения.</LI>
          <LI>Поток B пытается захватить ресурс X, но он уже захвачен потоком A и ожидает его освобождения.</LI>
        </OL>
        В итоге оба потока заблокированы и не могут продолжить выполнение, так как ожидают освобождения ресурсов, которые удерживают другие потоки.<br><br>
        Если deadlock не разрешается, программа останавливается и перестает отвечать, что может привести к нежелательным последствиям. Разрешение deadlock обычно включает в себя обнаружение циклических зависимостей ресурсов и прерывание блокировки для одного из потоков для разрыва замкнутого круга.
        </LI>
    </UL>
</details>


### **9. Какие варианты реализации многопоточности есть в Android?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>Класс 'Handler' и 'Looper' для управления потоками (Thread)</LI>
        <LI>Потоки (Thread), но создавать новые потоки напрямую сулит возможными ошибками, сложностями и опасностями, особенно при работе с пользовательским интерфейсом.</LI>
        <LI>Корутины (Kotlin Coroutines )</LI>
    </UL>
</details>


### **10. Что такое main thread? Какие операции нужно выполнять на main thread, а какие нельзя делать?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>main thread</b> - основной поток приложения, в котором обрабатываются изменения интерфейса, взаимодействие с ним от пользователя или системы. На этом потоке нельзя выполнять долгие операции, блокирующие операции, тяжелые (аычислительно интенсивные) операции.</LI>
    </UL>
</details>


## **Java Core**

#### [Содержание<---](#содержание)

### **1. Что такое Exceptions? Зачем они нужны?**

### **2. Зачем используют ключевые слова final, finally и finalize?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>final</b> - используется для создания неизменяемых переменных, констант и методов, а также для определения неизменяемых классов + класс не может быть наследован. </LI>
        <LI><b>finally</b> - используется в блоке try-catch-finally для выполнения кода независимо от того, возникло исключение или нет. Это используется, например, для освобождения ресурсов, закрытия файлов или соединений с базой данных, независимо от того, произошла ошибка или нет.</LI>
        <LI><b>finalize</b> - метод, который вызывается сборщиком мусора перед удалением объекта из памяти. <i>Использование не рекомендуется</i></LI>
    </UL>
</details>


### **3. Что такое абстрактный класс? Что такое интерфейс?**

### **4. Что такое анонимный класс? Использовали ли на практике? Для чего?**

### **5. Что такое статический класс (static class)?**

### **6. Что такое enum? Зачем его используют?**

### **7. Можем ли мы сделать конструктор приватным?**

### **8. Какая разница между ключевыми словами throw и throws?**

### **9. Какая разница между Error и Exception?**

### **10. Какая разница между checked и unchecked exception?**

### **11. Что такое Object class и какие методы он имеет?**

### **12. Какие существуют модификаторы доступа для классов? Какая разница между ними?**

### **13. Что такое итератор?**

### **14. Как безопасно удалить элемент из коллекции?**

### **15. Зачем нам переопределять equals() и когда не нужно это делать?**

### **16. Какой должен выполняться контракт при переопределении equals()?**

## **RxJava**

#### [Содержание<---](#содержание)

### **1. В чем разница между map() и flatMap() в RxJava?**

### **2. Когда используете observeOn(), а когда subscribeOn()?**

### **3. Как можно обработать ошибки в RxJava?**

### **4. Какие schedulers знаете в RxJava? Назовите их отличия.**

### **5. Что такое Disposable? Зачем его используют?**

### **6. В чем разница между Hot и Cold Observables? Назовите примеры в RxJava.**

## **Android SDK**

#### [Содержание<---](#содержание)

### **1. Какие базовые Android-компоненты можете назвать?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Activity</b> - представляет экран с пользовательским интерфейсом. Она является основным способом взаимодействия пользователя с приложением.</LI>
        <LI><b>Service</b> - компонент, который выполняет операции, необходимые для работы в фоновом режиме, даже когда пользователь не активен. Например, сервис может проигрывать музыку, загружать файлы или выполнять другие <b>длительные операции</b>.</LI>
        <LI><b>BroadcastReceiver</b> - обрабатывает системные объявления (broadcasts) о различных событиях, таких как получение SMS, подключение к сети и другие. Он может запускаться даже в том случае, если приложение не активно.</LI>
        <LI><b>ContentProvider</b> - единый интерфейс для управления данными приложения, такими как базы данных SQLite, файлы и другие. Он используется для обмена данными между различными приложениями Android.</LI>
    </UL>
</details>


### **2. Что такое ContentProvider?**

### **3. Какие типы Service знаете?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Foreground Service (Служба в первом плане)</b>: Этот тип службы используется для выполнения операций, которые должны оставаться видимыми для пользователя. Например, служба проигрывания музыки или загрузки файлов. Foreground Service обычно связан с уведомлением, чтобы пользователь знал, что приложение продолжает работать.</LI>
        <LI><b>Background Service (Служба в фоне)</b>: Этот тип службы выполняется в фоновом режиме и не отображает уведомлений пользователю. Обычно используется для выполнения операций, которые могут быть завершены после того, как пользователь покинет приложение.</LI>
        <LI><b>Bound Service (Привязанная служба)</b>: Этот тип службы используется для связи между компонентами Android, такими как активности и службы. Активность может связаться с привязанной службой, чтобы отправлять запросы и получать ответы. Привязанная служба останавливается, когда последний компонент, связанный с ней, отвязывается.</LI>
    </UL>
</details>

### **4. Что такое BroadcastReceiver и какие типы существуют?**

### **5. Для чего используют механизм фрагментов?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Фрагментов</b> - составная часть интерефейса (Activity)<br>Используется для повторного использования, создания адаптивного дизайна.</LI>
    </UL>
</details>

### **6. Опишите жизненный цикл Activity.**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>onCreate()</LI>
        <LI>onStart()</LI>
        <LI><i>onPause()</i></LI>
        <LI><i>onResume()</i></LI>
        <LI>onStop()</LI>
        <LI>onDestroy()</LI>
    </UL>
</details>

### **7. Опишите жизненный цикл Fragment.**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>onAttach() - связывается с Activity</LI>
        <LI>onCreate()</LI>
        <LI>onCreateView()</LI>
        <LI>onActivityCreate()</LI>
        <LI>onStart()</LI>
        <LI>onResume()</LI>
        <LI>onPause()</LI>
        <LI>onStop()</LI>
        <LI>onDestroyView()</LI>
        <LI>onDestroy()</LI>
        <LI>onDetach()</LI>
    </UL>
</details>


### **8. Есть ли у Fragment контекст? Если да, то как его получить?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>Context fragment привязан к контексту Activity, соответственно при попытке получить его, стоит ожидать контекст связанной активити. Получить его можно через метод <code>getContext()</code>.</LI>
    </UL>
</details>


### **9. Чем отличается Fragment от Activity? Зачем выдумали Fragment?**

### **10. Что такое изменение конфигурации? Что происходит с приложением на Android при этом?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>ЖЦ всех связанный объектов будет начат с начала. (onCreate будет вызван еще раз)</LI>
    </UL>
</details>


### **11. Что такое Intent? Что такое explicit/implicit Intent?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Intent в Android</b> - это объект, который представляет собой абстракцию операции, которая должна быть выполнена. Он обычно используется для перехода от одной активности (Activity) к другой, запуска службы (Service), отправки широковещательного сообщения (Broadcast), а также для связывания компонентов приложения.</LI>
        <UL>
          <LI><b>Явный (explicit) Intent</b> - это интент, который явно указывает компонент (Activity, Service, BroadcastReceiver) приложения, который должен быть запущен или связан. Например, если вы хотите запустить новую активность, вы указываете класс этой активности в явном Intent.</LI>
          <LI><b>Неявный (implicit) Intent</b> - это интент, который не указывает конкретного компонента, который должен быть запущен или связан. Вместо этого он указывает на определенное действие, которое должно быть выполнено, и система Android выбирает подходящий компонент для его обработки на основе фильтров Intent, объявленных в манифесте приложения другими компонентами. Например, если вы хотите открыть веб-страницу в браузере, но не знаете, какой браузер используется, вы можете использовать неявный Intent.</LI>
        </UL>
    </UL>
</details>


### **12. Что такое SharedPreferences?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>SharedPreferences</b> - постоянное хранилище на платформе Android. Применяются для хранения конфигурации приложения. По своей сути представляет из себя XML-файл, где данные хранятся парами (ключ, занчение). Файл хранится в /data/shared_prefs.<br>Получить экземпляр SharedPreferences можно от Context.getSharedPreferences(name = "имя_файла_с_настройками", mode = Context.MODE_XXXX).</LI>
        <UL>
        <LI><b>MODE_PRIVATE</b> - доступ только у приложения владельца</LI>
        <br>Остальные методы помечены как <b>deprecated</b>
        <LI><b><i>MODE_WORLD_READABLE</i></b> - только чтение</LI>
        <LI><b><i>MODE_WORLD_WRITEABLE</i></b> - только запись</LI>
        <LI><b><i>MODE_MULTI_PROCESS</i></b> - доступ к файлу имеют несколько процессов</LI>
        </UL>
    </UL>
</details>


### **13. Что такое ANR? Как избегать таких ситуаций?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>ANR (Application Not Response)</b> - приложение не отвечает. Может возникнуть, если вызвать delay в main потоке и других случаях, когда следует использовать отличный поток от main thread.</LI>
    </UL>
</details>


### **14. Что такое DataBinding?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **15. Что такое LiveData? Какие виды знаете?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>LiveData</b> - хранилище данных, работающее по принципу паттерна Observer (наблюдатель). В него можно поместить какой-либо объект и также на него можно подписаться и получать объекты, которые в него помещают.</LI>
    </UL>
</details>


### **16. Как создать ViewModel? Почему создавать ViewModel нужно именно так?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Неправильно</b> - просто в val вызвать конструктор.</LI>
        <LI><b>Правильно</b> - через ViewModelProvider</LI>
        <br>
        <LI>Чтобы жизненный цикл VM продолжался до полного закрытия приложения.</LI>
    </UL>
</details>


### **17. Что такое Context и зачем он?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Context</b> – это объект, который предоставляет доступ к базовым функциям приложения: доступ к ресурсам, к файловой системе, вызов активности и т.д. </LI>
        <LI>В свою очередь Context имеет свои методы, позволяющие получать доступ к ресурсам и другим объектам.</LI>
        <UL>
          <LI><code>getAssets()</code></LI>
          <LI><code>getResources()</code></LI>
          <LI><code>getPackageManager()</code></LI>
          <LI><code>getString()</code></LI>
          <LI><code>getSharedPrefsFile()</code></LI>
        </UL>
    </UL>
</details>


### **18. Что такое AndroidManifest.xml? Зачем его используют? Что мы можем там декларировать?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>AndroidManifest.xml</b> - обязательный файл для каждого приложения на платформе Android. Он содержит важную метаинформацию о приложении и необходим для правильной работы приложения на устройствах Android. Вот основные его функции:</LI>
        <OL>
        <LI><b>Описание приложения:</b> В файле AndroidManifest.xml содержится информация о приложении, такая как его название, версия, пакетное имя, иконка приложения и другие основные атрибуты.</LI>
        <LI><b>Компоненты приложения:</b> Здесь декларируются все компоненты приложения, такие как активности (&lt;activity&gt;), службы (&lt;service&gt;), приемники широковещательных сообщений (&lt;receiver&gt;) и провайдеры контента (&lt;provider&gt;). Это позволяет системе Android знать о наличии и структуре компонентов приложения.</LI>
        <LI><b>Разрешения:</b> В <code>AndroidManifest.xml</code> указываются разрешения, необходимые для доступа к различным системным ресурсам и функциям устройства, таким как доступ к интернету, камере, геолокации и другим. Это позволяет пользователям заранее знать, какие разрешения запрашивает приложение, и контролировать их предоставление.</LI>
        <LI><b>Фильтры намерений (Intent filters):</b> С помощью элементов &lt;intent-filter&gt; можно указать, какие действия (intent) компонент приложения может обрабатывать. Например, здесь определяются активности, которые должны быть запущены при определенных действиях пользователя или системы, таких как открытие определенного типа файлов или ссылок.</LI>
        <LI><b>Метаинформация:</b> В файле AndroidManifest.xml можно также задать дополнительную метаинформацию о приложении, такую как минимальная версия Android, необходимая для запуска приложения, описание, категории приложения и другие дополнительные атрибуты.</LI>
        </OL>
    </UL>
</details>

### **19. Перечислите layout, с которыми работали? Когда и какой нужно использовать?**

### **20. Расскажите, что нужно реализовать, чтобы отобразить список строк в RecyclerView.**

### **21. Объясните паттерн ViewHolder. Для чего он применяется?**

### **22. Что такое DiffUtil?**

### **23. Расскажите о ConstraintLayout.**

### **24. Для чего используют Group, Guideline, Barriers, Chains в ConstraintLayout?**

### **25. У вас есть Activity с двумя Fragment'ами, у одного есть кнопка, у другого TextView. При нажатии кнопки изменяется TextView. Как вы реализуете это?**

### **26. Что такое WorkManager? Когда используем?**

## **Kotlin**

#### [Содержание<---](#содержание)

### **1. Как вы понимаете термин Null safety?**

### **2. Что такое nullable и non-nullable типы? Какая разница между val и var?**

### **3. Как задекларировать getter/setter для property?**
<details>
  <summary><b>Answer</b></summary>
    <pre><code><span style="color:orange;">var</span> myProperty: Int
  <span style="color:orange;">get</span>() = field * 2
  <span style="color:orange;">set</span>(value) {
    field = value / 2
  }</pre></code>
</details>

### **4. Почему классы Kotlin по умолчанию final?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>Часть философии безопасного программирования в Kotlin.</LI>
    </UL>
</details>


### **5. Что такое sealed class?**

### **6. Что такое data classes?**

### **7. Какая разница между sealed class и enum?**

### **8. Почему у Kotlin нет checked exceptions?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>Это философи языка. Они будут выброшены только в рантайме, а компилятор их пропустит, в сравнении с Java подобные исключения нужно будет обработать в коде.</LI>
    </UL>
</details>

### **9. Что такое Extensions (расширение)? Использовали ли вы их на практике?**

### **10. Что такое перегрузка операторов (operator overloading)? Зачем нужен этот механизм?**

### **11. Как работают примитивы в Kotlin?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>Kotlin автоматически выполняет упаковку (boxing) примитивных типов данных в объекты при необходимости их использования в контексте, где требуется объект. Если объект никогда не принимает значение null, Kotlin может использовать прямое представление примитивного типа данных без его обертки. Также существует явные функции преобразования между примитивными типами данных и их обертками.</LI>
    </UL>
</details>

### **12. Расскажите об объекте Unit в Kotlin.**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Unit = void</b></LI>
        <LI><b>Функциональный тип.</b> Функциональные типы объявляются с использованием синтаксиса <code>(параметры) -> возвращаемый_тип</code></LI>
    </UL>
</details>


### **13. Расскажите об объекте Any в Kotlin.**

### **14. Как создать Singleton объект в Kotlin?**
<details>
<summary><b>Answer</b></summary>
<UL><LI><b>С использованием object:</b><br><br>
<pre><code><span style="color:orange;">object</span> MySingleton {
  <span style="color:orange;">init</span> {
    println(<span style="color:green;">"Singleton initialized"</span>)
  }
  <span style="color:orange;">fun</span> doSomething() {
    println(<span style="color:green;">"Singleton function called"</span>)
  }
}
<span style="color:gray;">// Использование синглтона</span>
MySingleton.doSomething()</pre></code></LI>
<LI><b>С использованием companion object:</b><br><br>
<pre><code><span style="color:orange;">class</span> MySingleton <span style="color:orange;">private constructor</span>() {
  <span style="color:orange;">companion object</span> {
      <span style="color:orange;">private val</span> <span style="color:MediumOrchid;">instance</span>: MySingleton <span style="color:orange;">by</span> lazy { MySingleton() }
    <span style="color:orange;">fun</span> <span style="color:DodgerBlue;">getInstance</span>(): MySingleton {
      <span style="color:orange;">return</span> <span style="color:MediumOrchid;">instance</span>
    }
  }
  <span style="color:orange;">init</span> {
    println(<span style="color:green;">"Singleton initialized"</span>)
  }
  <span style="color:orange;">fun</span> doSomething() {
    println(<span style="color:green;">"Singleton function called"</span>)
  }
}

<span style="color:gray;">// Использование синглтона</span>
<span style="color:orange;">val</span> singleton = MySingleton.getInstance()
singleton.doSomething()</pre></code></UL></details>

### **15. Что такое companion object?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>companion object = static</b></LI>
    </UL>
</details>

### **16. Чем отличается const val от val?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>const val</b> инициализируется значением на этапе компиляции</LI>
        <LI><b>val</b>  вычисляются во время выполнения программы</LI>
    </UL>
</details>

### **17. Какие знаете модификаторы доступа?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>дефолтные + internal</b></LI>
    </UL>
</details>

### **18. Что означает модификатор lateinit?**

### **19. Coroutines – что это за механизм? Использовали ли его на практике?**

### **20. Зачем нужны Coroutines? Чем они лучше обычных тредов?**

### **21. Что такое suspend-функция?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>suspend(рус. приостановить)</b></LI>
    </UL>
</details>


### **22. Что такое Job?**
<details>
  <summary><b>Основные методы</b></summary>
    <UL>
        <LI>start() - запускает выполнение задачи.</LI>
        <LI>cancel() - отменяет выполнение задачи.</LI>
        <LI>join() - блокирует текущий поток до завершения выполнения задачи.</LI>
        <LI>isActive - свойство, которое показывает, активна ли задача (не отменена и не завершена).</LI>
        <LI>isCancelled - свойство, которое показывает, отменена ли задача.</LI>
        <LI>isCompleted - свойство, которое показывает, завершена ли задача.</LI>
    </UL>
</details>


### **23. Что такое Dispatcher? Какие есть виды?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Dispatcher</b> - это компонент, управляющий тем, на каком потоке или пуле потоков выполняются корутины. Он определяет контекст выполнения для корутины, включая то, на каком потоке она будет запущена и продолжена после приостановки.</LI>
        <OL>
          <LI><b>Dispatchers.Default:</b> Предназначен для CPU-интенсивных операций. Использует пул потоков размером, соответствующим числу процессоров, доступных в системе. По умолчанию используется 1 или (число ядер CPU - 1) потоков.</LI>
          <LI><b>Dispatchers.IO:</b> Предназначен для операций ввода-вывода (I/O), таких как чтение/запись файлов, сетевые запросы и т. д. Использует пул потоков с переменным размером, который автоматически масштабируется в зависимости от нагрузки.</LI>
          <LI><b>Dispatchers.Main:</b> Для использования в Android. Он позволяет выполнять корутины на основном потоке пользовательского интерфейса (UI), что позволяет обновлять пользовательский интерфейс из фоновых задач.</LI>
          <LI><b>Dispatchers.Unconfined:</b> Позволяет выполнить корутину без привязки к конкретному потоку. Корутина будет начата в текущем потоке, но после приостановки может быть возобновлена в любом потоке.</LI>
        </OL>
    </UL>
</details>

### **24. Что такое Scope?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Scope (область)</b>- это контекст выполнения для корутин. Scope определяет, когда корутина должна быть активной и когда она должна завершиться.<br><br>Корутины могут быть запущены в рамках определенной области, которая может быть ограничена временем жизни, потоком выполнения или другими факторами. Scope управляет жизненным циклом корутины, позволяя ей быть активной в течение определенного периода времени.</LI>
    </UL>
</details>

## **Другое**

#### [Содержание<---](#содержание)

### **1. Расскажите, что такое memory leak. Как избежать?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **2. Как бы вы искали memory leak?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **3. Расскажите о Dependency injection. Какие варианты реализации в Android?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **4. Для чего нужна система контроля версий?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **5. Что такое Git?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **6. Для чего используем .gitignore-файл?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **7. Расскажите о командах push, pull, fetch в Git?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **8. Что такое merge и rebase? Какая разница?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **9. Что такое CI? Зачем используем?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


## **Практические задачи**

#### [Содержание<---](#содержание)

### **1. Разверните Linked List. Отпишите о зацикленности в LinkedList или ее отсутствии.**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **2. Напишите функцию, которая вернет n первых неотъемлемых чисел:**
```kotlin
un nMin(items: List<String>, n: Int): List<Int> {
//return n minimal non negative items
}

Пример вызова функции: nMin(listOf("1","-11","-12","22","100","-30",”2”, “5”), 3)

Ожидаемый результат: [1, 22, 100]
```
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **3. Что будет выведено в консоль? Объясните результат.**
```kotlin
var globalId = 0
data class User(val name: String) {
val id = globalId++
}
fun main(args: Array<String>) {
val user1 = User("User")
val user2 = User("User")
println(user1)
println(user2)
println(user1 == user2)
}
```
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>

### **4. Исправьте все ошибки в коде:**
```kotlin
class Animal
class Dog: Animal {}
```
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>

### **5. Для коллекции items:**
**Подсчитайте количество отрицательных элементов.
Вычислите среднее арифметическое значение отрицательных и неотрицательных чисел.**
```kotlin
val items = listOf(1, -2 ,-3 , 4, 5, 0, 2, -2)
```
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>