# **ВОПРОСЫ С СОБЕСЕДОВАНИЙ ПО ANDROID**

## **Содержание**

1. [Базовые вопросы](#базовые-вопросы)

    1.0 [Что такое SOLID?](#0-что-такое-solid)

    1.1 [Назовите основные принципы ооп.](#1-назовите-основные-принципы-ооп)

    1.2 [Что такое класс? Что такое интерфейс? Какая между ними разница?](#2-что-такое-класс-что-такое-интерфейс-какая-между-ними-разница)

    1.3 [Назовите базовые типы данных.](#3-назовите-базовые-типы-данных)

    1.4 [В чем отличие примитивных типов от объектов?](#4-в-чем-отличие-примитивных-типов-от-объектов)

    1.5 [Какая разница между абстрактным классом и интерфейсом?](#5-какая-разница-между-абстрактным-классом-и-интерфейсом)

    1.6 [Что такое паттерны проектирования? Какие паттерны вы знаете?](#6-что-такое-паттерны-проектирования-какие-паттерны-вы-знаете)

    1.7 [Чем отличается Java от Kotlin?](#7-чем-отличается-java-от-kotlin)

2. [Алгоритмы](#алгоритмы)

    2.8 [Что такое алгоритм и как выбрать правильный?](#8-что-такое-алгоритм-и-как-выбрать-правильный)

    2.9 [Что такое сложность алгоритма? Как и с помощью чего её можно вычислить?](#9-что-такое-сложность-алгоритма-как-и-с-помощью-чего-её-можно-вычислить)

    2.10 [Что такое нотация big-O?](#10-что-такое-нотация-big-o)

    2.11 [Что такое рекурсия?](#11-что-такое-рекурсия)

    2.12 [Какие алгоритмы сортировки вы знаете?](#12-какие-алгоритмы-сортировки-вы-знаете)

3. [Структуры данных](#структуры-данных)

    3.13 [Расскажите о таких структурах данных, как List, Set, Map?](#13-расскажите-о-таких-структурах-данных-как-list-set-map)

    3.14 [Какая разница между ArrayList и LinkedList?](#14-какая-разница-между-arraylist-и-linkedlist)

4. [Хранение данных](#хранение-данных)

    4.15 [Как можно хранить данные в Android?](#15-как-можно-хранить-данные-в-android)

    4.16 [Когда следует использовать SharedPreferences?](#16-когда-следует-использовать-sharedpreferences)

    4.17 [Из каких компонентов состоит библиотека Room?](#17-из-каких-компонентов-состоит-библиотека-room)

    4.18 [Что такое @PrimaryKey, @Ignore, @Embedded, @TypeConverters в Room?](#18-что-такое-primarykey-ignore-embedded-typeconverters-в-room)

    4.19 [Для чего нужна миграция в базах данных?](#19-для-чего-нужна-миграция-в-базах-данных)

5. [Работа с сетью](#работа-с-сетью)

    5.20 [Что такое JSON, XML?](#20-что-такое-json-xml)

    5.21 [Какие варианты реализации работы с сервером?](#21-какие-варианты-реализации-работы-с-сервером)

    5.22 [Что такое REST?](#22-что-такое-rest)

6. [Многопоточность, Java Core, RxJava](#многопоточность)

    6.23 [Что такое процесс?](#23-что-такое-процесс)

    6.24 [Что такое поток?](#24-что-такое-поток)

    6.25 [Для чего используют ключевое слово synchronized?](#25-для-чего-используют-ключевое-слово-synchronized)

    6.26 [Зачем синхронизировать потоки?](#26-зачем-синхронизировать-потоки)

    6.27 [Какая разница между синхронным и асинхронным исполнением?](#27-какая-разница-между-синхронным-и-асинхронным-исполнением)

    6.28 [Как мы можем создать поток в Java?](#28-как-мы-можем-создать-поток-в-java)

    6.29 [Что такое deadlock?](#29-что-такое-deadlock)

    6.30 [Какие варианты реализации многопоточности есть в Android?](#30-какие-варианты-реализации-многопоточности-есть-в-android)

    6.31 [Что такое main thread? Какие операции нужно выполнять на main thread, а какие нельзя делать?](#31-что-такое-main-thread-какие-операции-нужно-выполнять-на-main-thread-а-какие-нельзя-делать)

7. [Java Core](#java-core)

8. [RxJava](#rxjava)

9. [Android SDK](#android-sdk)

10. [Kotlin](#kotlin)

11. [Другое](#другое)

12. [Практические задачи](#практические-задачи)


## **Базовые вопросы** 

#### [Содержание<---](#содержание)

### **0. Что такое [SOLID](https://javarush.com/groups/posts/3650-principih-solid-kotorihe-sdelajut-kod-chijshe)?**

### **1. Назовите основные принципы ООП.**

<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Наследование</b> - создание новых сущностей(шаблонов) на основе уже существующих.</LI>
        <LI><b>Полиморфизм</b> - возможность иметь разные формы для одной и той же сущности. Он     делится на статический (мнимый) и динамический (истинный). Суть разделения  заключается в том, что разные виды происходят в разные этапы выполенения программы.  Статический (мнимый) - происходит на этапе компиляции, из примеров могу назвать  приведение типов, но это не применимо к строго типизированный языкам, к которым  относиться Kotlin и Java. Динамический (истинный) - происходит во рвемя выполенния   кода. Как вариант это несколько методов с разными входными аргументами.</LI>
        <UL>
            <LI><b>3 типа полиморфизма в Kotlin:</b></LI>
            <UL>
                <LI><b>Ad hoc (по случаю)</b> – одна функция определяется для различных типов данных. В классе прописывается несколько функций, которые принимают разные параметры. При вызове этой функции, компилятор определяет какая функция сработает по количеству и типам передаваемых параметров. Минус такого подхода, в том, что нужно наделать множество реализаций этой функции.</LI>
                <LI><b>Subtyping (полиморфизм включения)</b> – это реализация через принцип подстановки Барбары Лисков. Это один из принципов объектно-ориентированного программирования из аббревиатуры SOLID. Почитайте об этом. А звучит он так: функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом. То есть объект более узкого типа всегда может использоваться там, где может использоваться объект более широкого типа. Здесь, кстати и может сбить с толку факт отношений наследования родителя и потомка, о чем я упоминал вначале.</LI>
                <LI><b>Parametric (параметрический)</b> – программа может быть реализована через обобщенные типы. То есть без ориентации на конкретный тип. Касаемо Kotlin – это история про дженерики (или обобщенное программирование). О них поговорим в другой раз.</LI>
            </UL>
        </UL>
        <LI><b>Инкапсуляци</b> - сокрытие реализации.</LI>
        <LI><b>Абстракция</b> - набор общих характеристик.</LI>
        <LI><b>Посылка сообщений</b> - форма связи, взаимодействия между сущностями.</LI>
        <LI><b>Переиспользование</b> - все что перечислено выше работает на повторное использование кода.</LI>
    </UL>
</details>

### **2. Что такое класс? Что такое интерфейс? Какая между ними разница?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Класс</b> - это способ описания сущности. Его шаблон, который имеет минимальный набор общих характеристик для работы с ним. Классы являются ссылочным типом данных, тоесть в куче(heap) будет храниться только ссылка на данные из стэка. </LI>
        <UL>
            <LI><b>Объект</b> - это экземпляр класса, который имеет все теже поля и методы, но значения в разных объектха могут различаться. </LI>
        </UL>
        <LI><b>Интерфейс</b> изначально это шаблон проектирования. В Kotlin - это некое соглашение для класса, который будет использовать (наследоваться) интерфейс, которое обязывает последнего реализовать заключенный с интерфейсом контракт(методы/поля).</LI>
        <LI><b>Отличия</b>
        <UL>
            <LI><b>interface</b> под оберткой представляет из себя abstract class, который запрещает создавать объекты этого класса.</LI>
            <LI><b>class</b> в kotlin изначально *final*, наследоваться можно только от *open* классов, при этом наследование может быть только одинарное, ***interface*** в свою очередь поддерживает множественное наследование. </LI>
        </UL>
        </LI>
    </UL>
</details><br>

```kotlin
interface Movable{
    var speed: Int  // объявление свойства
    fun move()      // определение функции без реализации
    fun stop(){     // определение функции с реализацией по умолчанию
        println("Остановка")
    }
}
class Car : Movable{
    // обязательно реализовать(override) только то,
    // что в interface не имеет реализации по умолчанию
    override var speed = 60
    override fun move(){
        println("Машина едет со скоростью $speed км/ч")
    }
}
```

### **3. Назовите базовые типы данных.**

<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>В Kotlin все типы это классы. Any - топ класс, от которого наследуются другие классы, также есть подтип всех типов - Nothing(ничего).</LI>
        <LI>Все примитвные типы разделены на нулабельные и нет, дополнительно можно выделить платформ тайп, используется для обратной совместимости, когда не известено объект нулабельный или нет. </LI>
        <LI>Функциональные типы Unit.</LI>
        <LI>Коллекции, которые дополнительно разделены на изменяемые и нет.</LI>
    </UL>
</details>

### **4. В чем отличие примитивных типов от объектов?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>Кроме описанного ранее поясния, что такое <a href='#2-что-такое-класс-что-такое-интерфейс-какая-между-ними-разница'>класс</a>, также можно отметить, что объект будет иметь еще методы, которые будут выполнять какие либо действия.</LI>
    </UL>
</details>

### **5. Какая разница между абстрактным классом и интерфейсом?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Абстрактный класс</b> - это заготовка для классов, которые имеют общую сущность, а интерфейса - это контракт, который обязывает другой объект реализовать некоторые свойства/методы.</LI>
        <LI>Также абстрактный класс может иметь стандратное значение для поля, тоесть хранить какие-либо данные. Интерфейс же может иметь только стандартную реализацию методов.</LI>
    </UL>
</details>

### **6. Что такое паттерны проектирования? Какие паттерны вы знаете?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Паттерн</b> — это типовое решение для часто встречающейся задачи при создании программ. Они испльзуются для проектирования и структуризации программы.</LI>
        <UL>
            <LI><b>Фасад (Facade)</b> - абстрагирует работу с несколькими классами, объединяя их единым интерфейсом взаимодействия.</LI>
            <LI><b>Стратегия (Strategy)</b> - используется для семейства схожих алгоритмов. Позволяет выбирать алгоритм путём определения соответствующего класса.</LI>
            <LI><b>Прокси/Заместитель (Proxy)</b> -  является посредником между двумя другими объектами, и который реализует/ограничивает доступ к объекту, к которому обращаются через него.</LI>
            <LI><b>Шаблонный метод (Template method)</b> - определяет основу алгоритма и позволяет наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом.</LI>
            <LI><b>Шаблон делегирования (Delegation pattern)</b> - выражает некоторое поведение, но в реальности передаёт ответственность за выполнение этого поведения связанному объекту. <i>Поддерживается Kotlin нативно, через "Делегированные свойства"</i></LI>
            <LI><b>Одиночка (Singleton)</b> - такой класс, может иметь только один экземпляр. Конструктор приватный, можно получить ссылку на объект через соответствующий метод.</LI>
        </UL>
    </UL>
</details>

### **7. Чем отличается Java от Kotlin?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>Меньше кода = быстрее разработка.</LI>
        <LI>Null Safety для исклчения NullPointerExcpetion из Java.</LI>
        <LI>Расширение класса без наследования.</LI>
        <LI>Data-класс, для хранения данных, компилятор сгенерирует методы HashCode(), toString(), equal()/==.</LI>
    </UL>
</details>

## **Алгоритмы**

#### [Содержание<---](#содержание)

### **8. Что такое алгоритм и как выбрать правильный?**

### **9. Что такое сложность алгоритма? Как и с помощью чего её можно вычислить?**

### **10. Что такое нотация big-O?**

### **11. Что такое рекурсия?**

### **12. Какие алгоритмы сортировки вы знаете?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Быстрая</b></LI>
        <LI><b>Слиянием</b></LI>
        <LI><b>Пузырькем</b></LI>
        <LI><b>Поразрядная</b></LI>
    </UL>
</details>

## **Структуры данных**

#### [Содержание<---](#содержание)

### **13. Расскажите о таких структурах данных, как List, Set, Map?**

### **14. Какая разница между ArrayList и LinkedList?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>Аналогично с Array и List.</LI>
    </UL>
</details>

## **Хранение данных**

#### [Содержание<---](#содержание)

### **15. Как можно хранить данные в Android?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>SharedPreference</b> - хранение небольших объемов данных в виде пар ключ-значение. Отлично подходит для хранения настроек приложения.</LI>
        <LI><b>Файлы.</b></LI>
        <LI><b>SQLite</b> - легковесная реляционная база данных, встроенная в Android.Используется для хранения структурированных данных, таких как списки контактов, журналы и другие.</LI>
        <LI>Внешние службы хранения данных (Firebase Realtime Database, ...).</LI>
        <LI>DataStore (Part of Android Jetpack)</LI>
    </UL>
</details>

### **16. Когда следует использовать SharedPreferences?**

### **17. Из каких компонентов состоит библиотека [Room](https://developer.android.com/jetpack/androidx/releases/room)?**

### **18. Что такое @PrimaryKey, @Ignore, @Embedded, @TypeConverters в Room?**

### **19. Для чего нужна миграция в базах данных?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>- Применятся для переноса данных из текущей БД в новую без потери данных.</LI>
    </UL>
</details>

## **Работа с сетью**

#### [Содержание<---](#содержание)

### **20. Что такое JSON, XML?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>JSON</b> – это текстовый формат обмена данными, основанный на языке JavaScript. Используется для хранения притивных типов данных.</LI>
        <LI><b>XML</b> – это расширяемый язык разметки. Поддерживает более сложные типы данных (изображения, даты, ...)</LI>
    </UL>
</details>

### **21. Какие варианты реализации работы с сервером?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>HTTP-запросы (GET, POST, PUT, ...)</LI>
        <LI>WebSocket</LI>
        <LI>RESTful API</LI>
    </UL>
</details>

### **22. Что такое REST?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>REST (Representational State Transfer)</b> - это архитектурный стиль, используемый для создания веб-сервисов. Он определяет набор правил и ограничений для создания API, которые позволяют клиентам выполнять операции CRUD (Create, Read, Update, Delete) с ресурсами на сервере.
Система разделена на клиентов и серверы, которые независимо развиваются и могут изменяться без влияния на другую сторону. Все ресурсы в системе должны быть доступны через унифицированный интерфейс, который включает в себя стандартные методы HTTP (GET, POST, PUT, DELETE) и правильное использование HTTP статусных кодов.</LI>
    </UL>
</details>

## **Многопоточность**

#### [Содержание<---](#содержание)

### **23. Что такое процесс?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Процесс</b> - экземпляр исполняемой программы, под который были выделени ресурсы системы. Процесс ограничен адресным просранством и изначально не имеет доступ к переменным или структурам другого процесса.</LI>
    </UL>
</details>

### **24. Что такое поток?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Поток</b> - способ исполнения процесса, он находится в том же пространстве, что и процесс, но имеет доступ к другим потокам. Если поток изменил ресурс процесса, эти изменения видны для других потоков, дополнительно могу отметить, что каждый поток имеет свой стэк в рамках процесса, но также имеет доступ к стэкам и других потоков.</LI>
    </UL>
</details>

### **25. Для чего используют ключевое слово synchronized?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>Т.к. потоки работают независимо друг от друга, то может возникнуть ситуация, когда ресурс изменяется сразу несколькими потоками, к примеру вывод в консоль. I поток вывет свой код, а II поток выведет свой, в итоге они сольются.<br>
        Чтобы такая ситуация не возникала используются Mutex'ы.
        <UL>
            <LI><b>Mutex</b> ограничивает доступ к объекту в опредленное время для других потоков, если его уже взял какой-либо поток. Доступ будет открыт только после того, как взявший его поток закончит работу.</LI>
            <LI><b>Ключевое слово synchronized.</b> Оно используется для пометки метода или объекта. Если один поток зашел внутрь блока кода, который помечен словом synchronized, он моментально захватывает мьютекс объекта, и все другие потоки, которые попытаются зайти в этот же блок или метод вынуждены ждать, пока предыдущий поток не завершит свою работу и не освободит mutex.</LI>
        </UL>
        </LI>
    </UL>
</details>

### **26. Зачем синхронизировать потоки?**

### **27. Какая разница между синхронным и асинхронным исполнением?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Синхронное исполнение</b></LI>
        <UL>
            <LI>Задачи исполняются последовательно, одна за другой.<br>Порядок исполнения = порядку вызова.</LI>
            <LI>Исполняемая в момент задача блокирует выполнение следующей, соответственно вызываемый поток будет ожидать завершения задачи.</LI>
        </UL>
        <LI><b>Асинхронное исполнение</b></LI>
        <UL>
            <LI>Задачи выполняются разрознено без ожидания завершения других задач.</LI>
            <LI>Используется для выполнения длительных задач в фоне, без остановки основного потока(приложения).</LI>
        </UL>
    </UL>
</details>


### **28.1. Как мы можем создать поток в Java?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>От класса Thread можно наследоваться и описать исполнения какого-либо процесса в блоке метода <b><i>run()</b></i></LI>
    </UL>
</details>

### **28.2. Как мы можем создать поток в Kotlin?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Использование корутин (Coroutines)</b><br><b>Coroutines</b> - это легковесные потоки, которые не блокируют основной поток выполнения.</LI>
        <UL>
            <LI>Для испльзования корутин, нужно определить <b>область корутин</b>.
            <UL>
                <LI><b>GlobalScope</b> - глобальная область, которая доступна на протяжении всего жизненного цикла приложения. Соответственно является областью всего kotlin приложения.</LI>
                <LI><b>CoroutineScope</b> - локальная область, доступна только в рамках какого-либо компонента приложения.</LI>
                <UL>
                    <LI><b>ViewModelScope</b> - область, предназначенная для использования в архитектуре приложений, основанных на  архитектурном компоненте ViewModel из Android Jetpack. Эта область корутины автоматически отменяется при уничтожении ViewModel</LI>
                </UL>
                <LI><i>Чтобы в указанной области запустить корутину, функция должна быть помечана как <code>suspend</code></i><br>При определении (<code>fun getUsers(): Flow< String ></code>) функции-потока (в данном случае функции getUsers) необязательно использовать модификатор suspend.</LI>
            </UL>
        </UL>
        <LI><b>Использование асинхронных потоков (Flow)</b><br><b>Flow</b> - это интерфейс, для создания подобных потоков. По сути асинхронный поток - это объект Flow. Он типизируется (Flow < String > ) типом тех данных, которые должны передаваться в потоке.<br>Для создания объекта Flow применяется специальная функция <code><br>fun getUsers(): Flow<String> = flow {<br>&nbsp// создание асинхронного потока в функции flow<br>&nbspemit(item) // передаем значение в поток<br>}</code><br>Во внешнем коде в функции main вызываем функцию-поток getUsers(). Для управления объектами из потока для интерфейса Flow определен ряд функций, одной из которых является функция collect(). В качестве параметра она принимает функцию, в которую передает эмитируемый объект из потока. Так, в данном случае это просто функция вывода на консоль:<br><code>getUsers().collect { user -> println(user) }</code></LI>
    </UL>
</details>

### **29. Что такое deadlock?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>deadlock</b> - ситуация, когда потоки блокируются, что происхоит, к примеру, в следствии ситуации:
        <OL>
          <LI>Поток A захватывает ресурс X</LI>
          <LI>Поток B захватывает ресурс Y.</LI>
          <LI>Поток A пытается захватить ресурс Y, но он уже захвачен потоком B и ожидает его освобождения.</LI>
          <LI>Поток B пытается захватить ресурс X, но он уже захвачен потоком A и ожидает его освобождения.</LI>
        </OL>
        В итоге оба потока заблокированы и не могут продолжить выполнение, так как ожидают освобождения ресурсов, которые удерживают другие потоки.<br><br>
        Если deadlock не разрешается, программа останавливается и перестает отвечать, что может привести к нежелательным последствиям. Разрешение deadlock обычно включает в себя обнаружение циклических зависимостей ресурсов и прерывание блокировки для одного из потоков для разрыва замкнутого круга.
        </LI>
    </UL>
</details>


### **30. Какие варианты реализации многопоточности есть в Android?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>Класс 'Handler' и 'Looper' для управления потоками (Thread)</LI>
        <LI>Потоки (Thread), но создавать новые потоки напрямую сулит возможными ошибками, сложностями и опасностями, особенно при работе с пользовательским интерфейсом.</LI>
        <LI>Корутины (Kotlin Coroutines )</LI>
    </UL>
</details>


### **31. Что такое main thread? Какие операции нужно выполнять на main thread, а какие нельзя делать?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>main thread</b> - основной поток приложения, в котором обрабатываются изменения интерфейса, взаимодействие с ним от пользователя или системы. На этом потоке нельзя выполнять долгие операции, блокирующие операции, тяжелые (аычислительно интенсивные) операции.</LI>
    </UL>
</details>


## **Java Core**

#### [Содержание<---](#содержание)

### **32. Что такое Exceptions? Зачем они нужны?**

### **33. Зачем используют ключевые слова final, finally и finalize?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>final</b> - используется для создания неизменяемых переменных, констант и методов, а также для определения неизменяемых классов + класс не может быть наследован. </LI>
        <LI><b>finally</b> - используется в блоке try-catch-finally для выполнения кода независимо от того, возникло исключение или нет. Это используется, например, для освобождения ресурсов, закрытия файлов или соединений с базой данных, независимо от того, произошла ошибка или нет.</LI>
        <LI><b>finalize</b> - метод, который вызывается сборщиком мусора перед удалением объекта из памяти. <i>Использование не рекомендуется</i></LI>
    </UL>
</details>


### **34. Что такое абстрактный класс? Что такое интерфейс?**

### **35. Что такое анонимный класс? Использовали ли на практике? Для чего?**

### **36. Что такое статический класс (static class)?**

### **37. Что такое enum? Зачем его используют?**

### **38. Можем ли мы сделать конструктор приватным?**

### **39. Какая разница между ключевыми словами throw и throws?**

### **40. Какая разница между Error и Exception?**

### **41. Какая разница между checked и unchecked exception?**

### **42. Что такое Object class и какие методы он имеет?**

### **43. Какие существуют модификаторы доступа для классов? Какая разница между ними?**

### **44. Что такое итератор?**

### **45. Как безопасно удалить элемент из коллекции?**

### **46. Зачем нам переопределять equals() и когда не нужно это делать?**

### **47. Какой должен выполняться контракт при переопределении equals()?**

## **RxJava**

#### [Содержание<---](#содержание)

### **48. В чем разница между map() и flatMap() в RxJava?**

### **49. Когда используете observeOn(), а когда subscribeOn()?**

### **50. Как можно обработать ошибки в RxJava?**

### **51. Какие schedulers знаете в RxJava? Назовите их отличия.**

### **52. Что такое Disposable? Зачем его используют?**

### **53. В чем разница между Hot и Cold Observables? Назовите примеры в RxJava.**

## **Android SDK**

#### [Содержание<---](#содержание)

### **Какие базовые Android-компоненты можете назвать?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Activity</b> - представляет экран с пользовательским интерфейсом. Она является основным способом взаимодействия пользователя с приложением.</LI>
        <LI><b>Service</b> - компонент, который выполняет операции, необходимые для работы в фоновом режиме, даже когда пользователь не активен. Например, сервис может проигрывать музыку, загружать файлы или выполнять другие <b>длительные операции</b>.</LI>
        <LI><b>BroadcastReceiver</b> - обрабатывает системные объявления (broadcasts) о различных событиях, таких как получение SMS, подключение к сети и другие. Он может запускаться даже в том случае, если приложение не активно.</LI>
        <LI><b>ContentProvider</b> - единый интерфейс для управления данными приложения, такими как базы данных SQLite, файлы и другие. Он используется для обмена данными между различными приложениями Android.</LI>
    </UL>
</details>


### **55. Что такое ContentProvider?**

### **56. Какие типы Service знаете?**

### **57. Что такое BroadcastReceiver и какие типы существуют?**

### **58. Для чего используют механизм фрагментов?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Фрагментов</b> - составная часть интерефейса (Activity)<br>Используется для повторного использования, создания адаптивного дизайна.</LI>
    </UL>
</details>

### **59. Опишите жизненный цикл Activity.**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>onCreate()</LI>
        <LI>onStart()</LI>
        <LI><i>onPause()</i></LI>
        <LI><i>onResume()</i></LI>
        <LI>onStop()</LI>
        <LI>onDestroy()</LI>
    </UL>
</details>

### **60. Опишите жизненный цикл Fragment.**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>onAttach() - связывается с Activity</LI>
        <LI>onCreate()</LI>
        <LI>onCreateView()</LI>
        <LI>onActivityCreate()</LI>
        <LI>onStart()</LI>
        <LI>onResume()</LI>
        <LI>onPause()</LI>
        <LI>onStop()</LI>
        <LI>onDestroyView()</LI>
        <LI>onDestroy()</LI>
        <LI>onDetach()</LI>
    </UL>
</details>


### **61. Есть ли у Fragment контекст? Если да, то как его получить?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>Context fragment привязан к контексту Activity, соответственно при попытке получить его, стоит ожидать контекст связанной активити. Получить его можно через метод <code>getContext()</code>.</LI>
    </UL>
</details>


### **62. Чем отличается Fragment от Activity? Зачем выдумали Fragment?**

### **63. Что такое изменение конфигурации? Что происходит с приложением на Android при этом?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI>ЖЦ всех связанный объектов будет начат с начала. (onCreate будет вызван еще раз)</LI>
    </UL>
</details>


### **64. Что такое Intent? Что такое explicit/implicit Intent?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>Intent в Android</b> - это объект, который представляет собой абстракцию операции, которая должна быть выполнена. Он обычно используется для перехода от одной активности (Activity) к другой, запуска службы (Service), отправки широковещательного сообщения (Broadcast), а также для связывания компонентов приложения.</LI>
        <UL>
          <LI><b>Явный (explicit) Intent</b> - это интент, который явно указывает компонент (Activity, Service, BroadcastReceiver) приложения, который должен быть запущен или связан. Например, если вы хотите запустить новую активность, вы указываете класс этой активности в явном Intent.</LI>
          <LI><b>Неявный (implicit) Intent</b> - это интент, который не указывает конкретного компонента, который должен быть запущен или связан. Вместо этого он указывает на определенное действие, которое должно быть выполнено, и система Android выбирает подходящий компонент для его обработки на основе фильтров Intent, объявленных в манифесте приложения другими компонентами. Например, если вы хотите открыть веб-страницу в браузере, но не знаете, какой браузер используется, вы можете использовать неявный Intent.</LI>
        </UL>
    </UL>
</details>


### **65. Что такое SharedPreferences?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>SharedPreferences</b> - постоянное хранилище на платформе Android. Применяются для хранения конфигурации приложения. По своей сути представляет из себя XML-файл, где данные хранятся парами (ключ, занчение). Файл хранится в /data/shared_prefs.<br>Получить экземпляр SharedPreferences можно от Context.getSharedPreferences(name = "имя_файла_с_настройками", mode = Context.MODE_XXXX).</LI>
        <UL>
        <LI><b>MODE_PRIVATE</b> - доступ только у приложения владельца</LI>
        <br>Остальные методы помечены как <b>deprecated</b>
        <LI><b><i>MODE_WORLD_READABLE</i></b> - только чтение</LI>
        <LI><b><i>MODE_WORLD_WRITEABLE</i></b> - только запись</LI>
        <LI><b><i>MODE_MULTI_PROCESS</i></b> - доступ к файлу имеют несколько процессов</LI>
        </UL>
    </UL>
</details>


### **66. Что такое ANR? Как избегать таких ситуаций?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b>ANR (Application Not Response)</b> - приложение не отвечает. Может возникнуть, если вызвать delay в main потоке и других случаях, когда следует использовать отличный поток от main thread.</LI>
    </UL>
</details>


### **67. Что такое DataBinding?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **68. Что такое LiveData? Какие виды знаете?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **69. Как создать ViewModel? Почему создавать ViewModel нужно именно так?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **70. Что такое Context и зачем он?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **71. Что такое AndroidManifest.xml? Зачем его используют? Что мы можем там декларировать?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **72. Перечислите layout, с которыми работали? Когда и какой нужно использовать?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **73. Расскажите, что нужно реализовать, чтобы отобразить список строк в RecyclerView.**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **74. Объясните паттерн ViewHolder. Для чего он применяется?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **75. Что такое DiffUtil?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **76. Расскажите о ConstraintLayout.**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **77. Для чего используют Group, Guideline, Barriers, Chains в ConstraintLayout?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **78. У вас есть Activity с двумя Fragment'ами, у одного есть кнопка, у другого TextView. При нажатии кнопки изменяется TextView. Как вы реализуете это?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **79. Что такое WorkManager? Когда используем?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


## **Kotlin**

### **80. Как вы понимаете термин Null safety?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **81. Что такое nullable и non-nullable типы? Какая разница между val и var?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **82. Как задекларировать getter/setter для property?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **83. Почему классы Kotlin по умолчанию final?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **84. Что такое sealed class?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **85. Что такое data classes?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **86. Какая разница между sealed class и enum?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **87. Почему у Kotlin нет checked exceptions?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **88. Что такое Extensions? Использовали ли вы их на практике?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **89. Что такое перегрузка операторов (operator overloading)? Зачем нужен этот механизм?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **90. Как работают примитивы в Kotlin?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **91. Расскажите об объекте Unit в Kotlin.**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **92. Расскажите об объекте Any в Kotlin.**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **93. Как создать Singleton объект в Kotlin?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **94. Что такое companion object?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **95. Чем отличается const val от val?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **96. Какие знаете модификаторы доступа?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **97. Что означает модификатор lateinit?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **98. Coroutines – что это за механизм? Использовали ли его на практике?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **99. Зачем нужны Coroutines? Чем они лучше обычных тредов?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **100. Что такое suspend-функция?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **101. Что такое Job?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **102. Что такое Dispatcher? Какие есть виды?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **102. Что такое Scope?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **103. Как писать Java compatible API в Kotlin?**

## **Другое**

### **104. Расскажите, что такое memory leak. Как избежать?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **105. Как бы вы искали memory leak?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **106. Расскажите о Dependency injection. Какие варианты реализации в Android?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **107. Для чего нужна система контроля версий?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **108. Что такое Git?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **109. Для чего используем .gitignore-файл?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **110. Расскажите о командах push, pull, fetch в Git?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **111. Что такое merge и rebase? Какая разница?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **112. Что такое CI? Зачем используем?**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


## **Практические задачи**

### **113. Разверните Linked List. Отпишите о зацикленности в LinkedList или ее отсутствии.**
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **114. Напишите функцию, которая вернет n первых неотъемлемых чисел:**
```kotlin
un nMin(items: List<String>, n: Int): List<Int> {
//return n minimal non negative items
}

Пример вызова функции: nMin(listOf("1","-11","-12","22","100","-30",”2”, “5”), 3)

Ожидаемый результат: [1, 22, 100]
```
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>


### **115. Что будет выведено в консоль? Объясните результат.**
```kotlin
var globalId = 0
data class User(val name: String) {
val id = globalId++
}
fun main(args: Array<String>) {
val user1 = User("User")
val user2 = User("User")
println(user1)
println(user2)
println(user1 == user2)
}
```
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>

### **116. Исправьте все ошибки в коде:**
```kotlin
class Animal
class Dog: Animal {}
```
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>

### **117. Для коллекции items:**
**Подсчитайте количество отрицательных элементов.
Вычислите среднее арифметическое значение отрицательных и неотрицательных чисел.**
```kotlin
val items = listOf(1, -2 ,-3 , 4, 5, 0, 2, -2)
```
<details>
  <summary><b>Answer</b></summary>
    <UL>
        <LI><b></b></LI>
    </UL>
</details>